<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>iris.analysis &#8212; Iris 1.13.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.13.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="top" title="Iris 1.13.0 documentation" href="../../contents.html" />
    <link rel="up" title="Iris reference documentation" href="../iris.html" />
    <link rel="next" title="iris.analysis.calculus" href="analysis/calculus.html" />
    <link rel="prev" title="iris.TEST" href="TEST.html" />
 
    <META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE"> 

    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <script type="text/javascript" src="http://docs.python.org/2/_static/copybutton.js"></script>

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding: 1px 10px 1px 15px">
<p style="margin-left: 15px; font-weight:bolder; letter-spacing:0.1ex;">
<a href="../../index.html"><img src="../../_static/Iris7_1_trim_100.png" width=101 height=100 border="0" style="vertical-align:middle" alt="Logo"/></a>
<span style="font-size: 400%; vertical-align:middle"> Iris 1.13 </span>
</p>

</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="analysis/calculus.html" title="iris.analysis.calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="TEST.html" title="iris.TEST"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../iris.html" accesskey="U">Iris reference documentation</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="TEST.html"
                        title="previous chapter">iris.TEST</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="analysis/calculus.html"
                        title="next chapter">iris.analysis.calculus</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/iris/iris/analysis.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iris-analysis">
<span id="id1"></span><h1>iris.analysis<a class="headerlink" href="#iris-analysis" title="Permalink to this headline">¶</a></h1>
<div class="sidebar">
<p class="first sidebar-title">Modules in this package</p>
<div class="toctree-wrapper last compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="analysis/calculus.html">iris.analysis.calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/cartography.html">iris.analysis.cartography</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/geometry.html">iris.analysis.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/interpolate.html">iris.analysis.interpolate</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/maths.html">iris.analysis.maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/stats.html">iris.analysis.stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/trajectory.html">iris.analysis.trajectory</a></li>
</ul>
</div>
</div>
<span class="target" id="module-iris.analysis"></span><p>A package providing <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a> analysis support.</p>
<p>This module defines a suite of <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instances,
which are used to specify the statistical measure to calculate over a
<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, using methods such as
<a class="reference internal" href="cube.html#iris.cube.Cube.aggregated_by" title="iris.cube.Cube.aggregated_by"><code class="xref py py-meth docutils literal"><span class="pre">aggregated_by()</span></code></a> and <a class="reference internal" href="cube.html#iris.cube.Cube.collapsed" title="iris.cube.Cube.collapsed"><code class="xref py py-meth docutils literal"><span class="pre">collapsed()</span></code></a>.</p>
<p>The <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> is a convenience class that allows
specific statistical aggregation operators to be defined and instantiated.
These operators can then be used to collapse, or partially collapse, one or
more dimensions of a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as discussed in
<a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics"><span class="std std-ref">Cube statistics</span></a>.</p>
<p>In particular, <a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics-collapsing"><span class="std std-ref">Collapsing entire data dimensions</span></a> discusses how to use
<a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-const docutils literal"><span class="pre">MEAN</span></code></a> to average over one dimension of a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>,
and also how to perform weighted <a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics-collapsing-average"><span class="std std-ref">Area averaging</span></a>.
While <a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics-aggregated-by"><span class="std std-ref">Partially reducing data dimensions</span></a> shows how to aggregate similar
groups of data points along a single dimension, to result in fewer points
in that dimension.</p>
<p>The gallery contains several interesting worked examples of how an
<a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> may be used, including:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../../examples/Meteorology/COP_1d_plot.html#meteorology-cop-1d-plot"><span class="std std-ref">Global average annual temperature plot</span></a></li>
<li><a class="reference internal" href="../../examples/General/SOI_filtering.html#general-soi-filtering"><span class="std std-ref">Applying a filter to a time-series</span></a></li>
<li><a class="reference internal" href="../../examples/Meteorology/hovmoller.html#meteorology-hovmoller"><span class="std std-ref">Hovmoller diagram of monthly surface temperature</span></a></li>
<li><a class="reference internal" href="../../examples/Meteorology/lagged_ensemble.html#meteorology-lagged-ensemble"><span class="std std-ref">Seasonal ensemble model plots</span></a></li>
<li><a class="reference internal" href="../../examples/General/custom_aggregation.html#general-custom-aggregation"><span class="std std-ref">Calculating a custom statistic</span></a></li>
</ul>
</div></blockquote>
<p>In this module:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#iris.analysis.COUNT" title="iris.analysis.COUNT"><code class="xref py py-obj docutils literal"><span class="pre">COUNT</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.GMEAN" title="iris.analysis.GMEAN"><code class="xref py py-obj docutils literal"><span class="pre">GMEAN</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.HMEAN" title="iris.analysis.HMEAN"><code class="xref py py-obj docutils literal"><span class="pre">HMEAN</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.MAX" title="iris.analysis.MAX"><code class="xref py py-obj docutils literal"><span class="pre">MAX</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-obj docutils literal"><span class="pre">MEAN</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.MEDIAN" title="iris.analysis.MEDIAN"><code class="xref py py-obj docutils literal"><span class="pre">MEDIAN</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.MIN" title="iris.analysis.MIN"><code class="xref py py-obj docutils literal"><span class="pre">MIN</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.PEAK" title="iris.analysis.PEAK"><code class="xref py py-obj docutils literal"><span class="pre">PEAK</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.PERCENTILE" title="iris.analysis.PERCENTILE"><code class="xref py py-obj docutils literal"><span class="pre">PERCENTILE</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.PROPORTION" title="iris.analysis.PROPORTION"><code class="xref py py-obj docutils literal"><span class="pre">PROPORTION</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.RMS" title="iris.analysis.RMS"><code class="xref py py-obj docutils literal"><span class="pre">RMS</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.STD_DEV" title="iris.analysis.STD_DEV"><code class="xref py py-obj docutils literal"><span class="pre">STD_DEV</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.SUM" title="iris.analysis.SUM"><code class="xref py py-obj docutils literal"><span class="pre">SUM</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.VARIANCE" title="iris.analysis.VARIANCE"><code class="xref py py-obj docutils literal"><span class="pre">VARIANCE</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.WPERCENTILE" title="iris.analysis.WPERCENTILE"><code class="xref py py-obj docutils literal"><span class="pre">WPERCENTILE</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.coord_comparison" title="iris.analysis.coord_comparison"><code class="xref py py-obj docutils literal"><span class="pre">coord_comparison</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-obj docutils literal"><span class="pre">Aggregator</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.WeightedAggregator" title="iris.analysis.WeightedAggregator"><code class="xref py py-obj docutils literal"><span class="pre">WeightedAggregator</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.clear_phenomenon_identity" title="iris.analysis.clear_phenomenon_identity"><code class="xref py py-obj docutils literal"><span class="pre">clear_phenomenon_identity</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-obj docutils literal"><span class="pre">Linear</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-obj docutils literal"><span class="pre">AreaWeighted</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-obj docutils literal"><span class="pre">Nearest</span></code></a></li>
<li><a class="reference internal" href="#iris.analysis.UnstructuredNearest" title="iris.analysis.UnstructuredNearest"><code class="xref py py-obj docutils literal"><span class="pre">UnstructuredNearest</span></code></a></li>
</ul>
</div></blockquote>
<dl class="data">
<dt id="iris.analysis.COUNT">
<code class="descclassname">iris.analysis.</code><code class="descname">COUNT</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.COUNT" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that counts the number
of <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> data occurrences that satisfy a particular
criterion, as defined by a user supplied <em>function</em>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>function (callable):</dt>
<dd><p class="first last">A function which converts an array of data values into a corresponding
array of True/False values.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the number of <em>ensemble members</em> with precipitation exceeding 10
(in cube data units) could be calculated with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;ensemble_member&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">COUNT</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="#iris.analysis.PROPORTION" title="iris.analysis.PROPORTION"><code class="xref py py-func docutils literal"><span class="pre">PROPORTION()</span></code></a> aggregator.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.GMEAN">
<code class="descclassname">iris.analysis.</code><code class="descname">GMEAN</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.GMEAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates the
geometric mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.gmean.html#scipy.stats.mstats.gmean" title="(in SciPy v0.19.0)"><code class="xref py py-func docutils literal"><span class="pre">scipy.stats.mstats.gmean()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal geometric means over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">GMEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.HMEAN">
<code class="descclassname">iris.analysis.</code><code class="descname">HMEAN</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.HMEAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates the
harmonic mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hmean.html#scipy.stats.mstats.hmean" title="(in SciPy v0.19.0)"><code class="xref py py-func docutils literal"><span class="pre">scipy.stats.mstats.hmean()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal harmonic mean over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">HMEAN</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The harmonic mean is only valid if all data values are greater
than zero.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MAX">
<code class="descclassname">iris.analysis.</code><code class="descname">MAX</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.MAX" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the maximum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.max.html#numpy.ma.max" title="(in NumPy v1.12)"><code class="xref py py-func docutils literal"><span class="pre">numpy.ma.max()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal maximums over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MEAN">
<code class="descclassname">iris.analysis.</code><code class="descname">MEAN</code> &rarr; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.MEAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.average.html#numpy.ma.average" title="(in NumPy v1.12)"><code class="xref py py-func docutils literal"><span class="pre">numpy.ma.average()</span></code></a>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>mdtol (float):</dt>
<dd><p class="first last">Tolerance of missing data. The value returned in each element of the
returned array will be masked if the fraction of masked data contributing
to that element exceeds mdtol. This fraction is calculated based on the
number of masked elements. mdtol=0 means no missing data is tolerated
while mdtol=1 means the resulting element will be masked if and only if
all the contributing elements are masked. Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>weights (float ndarray):</dt>
<dd><p class="first last">Weights matching the shape of the cube or the length of the window
for rolling window operations. Note that, latitude/longitude area
weights can be calculated using
<a class="reference internal" href="analysis/cartography.html#iris.analysis.cartography.area_weights" title="iris.analysis.cartography.area_weights"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.cartography.area_weights()</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>returned (boolean):</dt>
<dd><p class="first last">Set this to True to indicate that the collapsed weights are to be
returned along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal means over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute a weighted area average:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">)</span>
<span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">collapsed_weights</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span>
                                                   <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">,</span>
                                                   <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                   <span class="n">returned</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Lazy operation is supported, via <a class="reference external" href="https://biggus.readthedocs.io/en/latest/computation.html#biggus.mean" title="(in Biggus v0.15.0)"><code class="xref py py-func docutils literal"><span class="pre">biggus.mean()</span></code></a>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MEDIAN">
<code class="descclassname">iris.analysis.</code><code class="descname">MEDIAN</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.MEDIAN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the median over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.median.html#numpy.ma.median" title="(in NumPy v1.12)"><code class="xref py py-func docutils literal"><span class="pre">numpy.ma.median()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal medians over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEDIAN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MIN">
<code class="descclassname">iris.analysis.</code><code class="descname">MIN</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the minimum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.min.html#numpy.ma.min" title="(in NumPy v1.12)"><code class="xref py py-func docutils literal"><span class="pre">numpy.ma.min()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal minimums over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.PEAK">
<code class="descclassname">iris.analysis.</code><code class="descname">PEAK</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.PEAK" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the peak value derived from a spline interpolation over a
<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>.</p>
<p>The peak calculation takes into account nan values. Therefore, if the number
of non-nan values is zero the result itself will be an array of nan values.</p>
<p>The peak calculation also takes into account masked values. Therefore, if the
number of non-masked values is zero the result itself will be a masked array.</p>
<p>If multiple coordinates are specified, then the peak calculations are
performed individually, in sequence, for each coordinate specified.</p>
<p><strong>For example</strong>:</p>
<p>To compute the peak over the <em>time</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PEAK</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.PERCENTILE">
<code class="descclassname">iris.analysis.</code><code class="descname">PERCENTILE</code><a class="headerlink" href="#iris.analysis.PERCENTILE" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="xref py py-class docutils literal"><span class="pre">PercentileAggregator</span></code> instance that calculates the
percentile over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v0.19.0)"><code class="xref py py-func docutils literal"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>percent (float or sequence of floats):</dt>
<dd><p class="first last">Percentile rank/s at which to extract value/s.</p>
</dd>
</dl>
</li>
</ul>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>alphap (float):</dt>
<dd><p class="first last">Plotting positions parameter, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v0.19.0)"><code class="xref py py-func docutils literal"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>betap (float):</dt>
<dd><p class="first last">Plotting positions parameter, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v0.19.0)"><code class="xref py py-func docutils literal"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.
Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the 10th and 90th percentile over <em>time</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PERCENTILE</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.PROPORTION">
<code class="descclassname">iris.analysis.</code><code class="descname">PROPORTION</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.PROPORTION" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates the
proportion, as a fraction, of <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> data occurrences
that satisfy a particular criterion, as defined by a user supplied
<em>function</em>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>function (callable):</dt>
<dd><p class="first last">A function which converts an array of data values into a corresponding
array of True/False values.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the probability of precipitation exceeding 10
(in cube data units) across <em>ensemble members</em> could be calculated with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;ensemble_member&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PROPORTION</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, the proportion of <em>time</em> precipitation exceeded 10
(in cube data units) could be calculated with:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PROPORTION</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">The <a class="reference internal" href="#iris.analysis.COUNT" title="iris.analysis.COUNT"><code class="xref py py-func docutils literal"><span class="pre">COUNT()</span></code></a> aggregator.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.RMS">
<code class="descclassname">iris.analysis.</code><code class="descname">RMS</code> &rarr; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.RMS" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the root mean square over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
((x0**2 + x1**2 + ... + xN-1**2) / N) ** 0.5.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>weights (float ndarray):</dt>
<dd><p class="first last">Weights matching the shape of the cube or the length of the window for
rolling window operations. The weights are applied to the squares when
taking the mean.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the zonal root mean square over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">RMS</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.STD_DEV">
<code class="descclassname">iris.analysis.</code><code class="descname">STD_DEV</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.STD_DEV" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the standard deviation over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as
computed by <code class="xref py py-func docutils literal"><span class="pre">numpy.ma.std()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>ddof (integer):</dt>
<dd><p class="first last">Delta degrees of freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal standard deviations over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">STD_DEV</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the biased standard deviation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">STD_DEV</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Lazy operation is supported, via <a class="reference external" href="https://biggus.readthedocs.io/en/latest/computation.html#biggus.std" title="(in Biggus v0.15.0)"><code class="xref py py-func docutils literal"><span class="pre">biggus.std()</span></code></a>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.SUM">
<code class="descclassname">iris.analysis.</code><code class="descname">SUM</code> &rarr; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.SUM" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the sum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by <code class="xref py py-func docutils literal"><span class="pre">numpy.ma.sum()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>weights (float ndarray):</dt>
<dd><p class="first last">Weights matching the shape of the cube, or the length of
the window for rolling window operations. Weights should be
normalized before using them with this aggregator if scaling
is not intended.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>returned (boolean):</dt>
<dd><p class="first last">Set this to True to indicate the collapsed weights are to be returned
along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute an accumulation over the <em>time</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute a weighted rolling sum e.g. to apply a digital filter:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span>
                             <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.VARIANCE">
<code class="descclassname">iris.analysis.</code><code class="descname">VARIANCE</code> &rarr; Aggregator instance.<a class="headerlink" href="#iris.analysis.VARIANCE" title="Permalink to this definition">¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> instance that calculates
the variance over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>, as computed by
<code class="xref py py-func docutils literal"><span class="pre">numpy.ma.var()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>ddof (integer):</dt>
<dd><p class="first last">Delta degrees of freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal variance over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the biased variance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Lazy operation is supported, via <a class="reference external" href="https://biggus.readthedocs.io/en/latest/computation.html#biggus.var" title="(in Biggus v0.15.0)"><code class="xref py py-func docutils literal"><span class="pre">biggus.var()</span></code></a>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.WPERCENTILE">
<code class="descclassname">iris.analysis.</code><code class="descname">WPERCENTILE</code><a class="headerlink" href="#iris.analysis.WPERCENTILE" title="Permalink to this definition">¶</a></dt>
<dd><p>An <code class="xref py py-class docutils literal"><span class="pre">WeightedPercentileAggregator</span></code> instance that
calculates the weighted percentile over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>percent (float or sequence of floats):</dt>
<dd><p class="first last">Percentile rank/s at which to extract value/s.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>weights (float ndarray):</dt>
<dd><p class="first last">Weights matching the shape of the cube or the length of the window
for rolling window operations. Note that, latitude/longitude area
weights can be calculated using
<a class="reference internal" href="analysis/cartography.html#iris.analysis.cartography.area_weights" title="iris.analysis.cartography.area_weights"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.cartography.area_weights()</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul>
<li><dl class="first docutils">
<dt>returned (boolean):</dt>
<dd><p class="first last">Set this to True to indicate that the collapsed weights are to be
returned along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kind (string or int):</dt>
<dd><p class="first last">Specifies the kind of interpolation used, see
<code class="xref py py-func docutils literal"><span class="pre">scipy.interpolate.interp1d()</span></code> Defaults to &#8220;linear&#8221;, which is
equivalent to alphap=0.5, betap=0.5 in <cite>iris.analysis.PERCENTILE</cite></p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="function">
<dt id="iris.analysis.coord_comparison">
<code class="descclassname">iris.analysis.</code><code class="descname">coord_comparison</code><span class="sig-paren">(</span><em>*cubes</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.coord_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to help compare coordinates on one or more cubes
by their metadata.</p>
<p>Return a dictionary where the key represents the statement,
&#8220;Given these cubes list the coordinates which,
when grouped by metadata, are/have...&#8221;</p>
<p>Keys:</p>
<ul>
<li><dl class="first docutils">
<dt>grouped_coords</dt>
<dd><p class="first last">A list of coordinate groups of all the coordinates grouped together
by their coordinate definition</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ungroupable</dt>
<dd><p class="first last">A list of coordinate groups which contain at least one None,
meaning not all Cubes provide an equivalent coordinate</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>not_equal</dt>
<dd><p class="first last">A list of coordinate groups of which not all are equal
(superset of ungroupable)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>no_data_dimension</dt>
<dd><p class="first last">A list of coordinate groups of which all have no data dimensions on
their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>scalar</dt>
<dd><p class="first last">A list of coordinate groups of which all have shape (1, )</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>non_equal_data_dimension</dt>
<dd><p class="first last">A list of coordinate groups of which not all have the same
data dimension on their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>non_equal_shape</dt>
<dd><p class="first last">A list of coordinate groups of which not all have the same shape</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>equal_data_dimension</dt>
<dd><p class="first last">A list of coordinate groups of which all have the same data dimension
on their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>equal</dt>
<dd><p class="first last">A list of coordinate groups of which all are equal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ungroupable_and_dimensioned</dt>
<dd><p class="first last">A list of coordinate groups of which not all cubes had an equivalent
(in metadata) coordinate which also describe a data dimension</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dimensioned</dt>
<dd><p class="first last">A list of coordinate groups of which all describe a data dimension on
their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ignorable</dt>
<dd><p class="first last">A list of scalar, ungroupable non_equal coordinate groups</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>resamplable</dt>
<dd><p class="first last">A list of equal, different data dimensioned coordinate groups</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>transposable</dt>
<dd><p class="first last">A list of non equal, same data dimensioned, non scalar coordinate groups</p>
</dd>
</dl>
</li>
</ul>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">coord_comparison</span><span class="p">(</span><span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;All equal coordinates: &#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;equal&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>The <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">Aggregator</span></code></a> class provides common aggregation functionality.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.Aggregator">
<em class="property">class </em><code class="descclassname">iris.analysis.</code><code class="descname">Aggregator</code><span class="sig-paren">(</span><em>cell_method</em>, <em>call_func</em>, <em>units_func=None</em>, <em>lazy_func=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">iris.analysis._Aggregator</span></code></p>
<p>Create an aggregator for the given <code class="xref py py-data docutils literal"><span class="pre">call_func</span></code>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>cell_method (string):</dt>
<dd><p class="first last">Cell method definition formatter.  Used in the fashion
&#8220;cell_method.format(**kwargs)&#8221;, to produce a cell-method string
which can include keyword values.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>call_func (callable):</dt>
<dd><div class="first line-block">
<div class="line"><em>Call signature</em>: (data, axis=None, **kwargs)</div>
</div>
<p class="last">Data aggregation function.
Returns an aggregation result, collapsing the &#8216;axis&#8217; dimension of
the &#8216;data&#8217; argument.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>units_func (callable):</dt>
<dd><div class="first line-block">
<div class="line"><em>Call signature</em>: (units)</div>
</div>
<p class="last">If provided, called to convert a cube&#8217;s units.
Returns an <code class="xref py py-class docutils literal"><span class="pre">cf_units.Unit</span></code>, or a
value that can be made into one.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>lazy_func (callable or None):</dt>
<dd><p class="first last">An alternative to <code class="xref py py-data docutils literal"><span class="pre">call_func</span></code> implementing a lazy
aggregation. Note that, it need not support all features of the
main operation, but should raise an error in unhandled cases.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Additional kwargs::</dt>
<dd>Passed through to <code class="xref py py-data docutils literal"><span class="pre">call_func</span></code> and <code class="xref py py-data docutils literal"><span class="pre">lazy_func</span></code>.</dd>
</dl>
<p>Aggregators are used by cube aggregation methods such as
<a class="reference internal" href="cube.html#iris.cube.Cube.collapsed" title="iris.cube.Cube.collapsed"><code class="xref py py-meth docutils literal"><span class="pre">collapsed()</span></code></a> and
<a class="reference internal" href="cube.html#iris.cube.Cube.aggregated_by" title="iris.cube.Cube.aggregated_by"><code class="xref py py-meth docutils literal"><span class="pre">aggregated_by()</span></code></a>.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>A variety of ready-made aggregators are provided in this module, such
as <a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-data docutils literal"><span class="pre">MEAN</span></code></a> and <a class="reference internal" href="#iris.analysis.MAX" title="iris.analysis.MAX"><code class="xref py py-data docutils literal"><span class="pre">MAX</span></code></a>.  Custom
aggregators can also be created for special purposes, see
<a class="reference internal" href="../../examples/General/custom_aggregation.html#general-custom-aggregation"><span class="std std-ref">Calculating a custom statistic</span></a> for a worked example.</p>
<dl class="method">
<dt id="iris.analysis.Aggregator.aggregate">
<code class="descname">aggregate</code><span class="sig-paren">(</span><em>data</em>, <em>axis</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the aggregation function given the data.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the &#8220;percent&#8221; keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>data (array):</dt>
<dd><p class="first last">Data array.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis (int):</dt>
<dd><p class="first last">Axis to aggregate over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>mdtol (float):</dt>
<dd><p class="first last">Tolerance of missing data. The value returned will be masked if
the fraction of data to missing data is less than or equal to
mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1
will return the resulting value from the aggregation function.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs:</dt>
<dd><p class="first last">All keyword arguments apart from those specified above, are
passed through to the data aggregation function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The aggregated data.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.aggregate_shape">
<code class="descname">aggregate_shape</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.aggregate_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the new dimension/s created by the aggregator.</p>
<p>Kwargs:</p>
<ul class="simple">
<li>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords.</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A tuple of the aggregate shape.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.lazy_aggregate">
<code class="descname">lazy_aggregate</code><span class="sig-paren">(</span><em>data</em>, <em>axis</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.lazy_aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform aggregation over the data with a lazy operation, analogous to
the &#8216;aggregate&#8217; result.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the &#8220;percent&#8221; keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>data (array):</dt>
<dd><p class="first last">A lazy array (<code class="xref py py-class docutils literal"><span class="pre">biggus.Array</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis (int or list of int):</dt>
<dd><p class="first last">The dimensions to aggregate over &#8211; note that this is defined
differently to the &#8216;aggregate&#8217; method &#8216;axis&#8217; argument, which only
accepts a single dimension index.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>kwargs:</dt>
<dd><p class="first last">All keyword arguments are passed through to the data aggregation
function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A lazy array representing the aggregation operation
(<code class="xref py py-class docutils literal"><span class="pre">biggus.Array</span></code>).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the aggregator.</p>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.post_process">
<code class="descname">post_process</code><span class="sig-paren">(</span><em>collapsed_cube</em>, <em>data_result</em>, <em>coords</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.post_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>collapsed_cube:</dt>
<dd><p class="first last">A <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>data_result:</dt>
<dd><p class="first last">Result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coords:</dt>
<dd><p class="first last">The one or more coordinates that were aggregated over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the &#8220;ddof&#8221;
keyword from a standard deviation aggregator).</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The collapsed cube with its aggregated data payload.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.update_metadata">
<code class="descname">update_metadata</code><span class="sig-paren">(</span><em>cube</em>, <em>coords</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.update_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Update cube cell method metadata w.r.t the aggregation function.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>cube (<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a>):</dt>
<dd><p class="first last">Source cube that requires metadata update.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coords (<a class="reference internal" href="coords.html#iris.coords.Coord" title="iris.coords.Coord"><code class="xref py py-class docutils literal"><span class="pre">iris.coords.Coord</span></code></a>):</dt>
<dd><p class="first last">The one or more coordinates that were aggregated.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li>This function is intended to be used in conjuction with aggregate()
and should be passed the same keywords (for example, the &#8220;ddof&#8221;
keyword for a standard deviation aggregator).</li>
</ul>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>Convenience class that supports common weighted aggregation functionality.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.WeightedAggregator">
<em class="property">class </em><code class="descclassname">iris.analysis.</code><code class="descname">WeightedAggregator</code><span class="sig-paren">(</span><em>cell_method</em>, <em>call_func</em>, <em>units_func=None</em>, <em>lazy_func=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal"><span class="pre">iris.analysis.Aggregator</span></code></a></p>
<p>Create a weighted aggregator for the given <code class="xref py py-data docutils literal"><span class="pre">call_func</span></code>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>cell_method (string):</dt>
<dd><p class="first last">Cell method string that supports string format substitution.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>call_func (callable):</dt>
<dd><p class="first last">Data aggregation function. Call signature <cite>(data, axis, **kwargs)</cite>.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>units_func (callable):</dt>
<dd><p class="first last">Units conversion function.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>lazy_func (callable or None):</dt>
<dd><p class="first last">An alternative to <code class="xref py py-data docutils literal"><span class="pre">call_func</span></code> implementing a lazy
aggregation. Note that, it need not support all features of the
main operation, but should raise an error in unhandled cases.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Additional kwargs:</dt>
<dd>Passed through to <code class="xref py py-data docutils literal"><span class="pre">call_func</span></code> and <code class="xref py py-data docutils literal"><span class="pre">lazy_func</span></code>.</dd>
</dl>
<dl class="method">
<dt id="iris.analysis.WeightedAggregator.aggregate">
<code class="descname">aggregate</code><span class="sig-paren">(</span><em>data</em>, <em>axis</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the aggregation function given the data.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the &#8220;percent&#8221; keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>data (array):</dt>
<dd><p class="first last">Data array.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis (int):</dt>
<dd><p class="first last">Axis to aggregate over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>mdtol (float):</dt>
<dd><p class="first last">Tolerance of missing data. The value returned will be masked if
the fraction of data to missing data is less than or equal to
mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1
will return the resulting value from the aggregation function.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>kwargs:</dt>
<dd><p class="first last">All keyword arguments apart from those specified above, are
passed through to the data aggregation function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The aggregated data.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.aggregate_shape">
<code class="descname">aggregate_shape</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.aggregate_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>The shape of the new dimension/s created by the aggregator.</p>
<p>Kwargs:</p>
<ul class="simple">
<li>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords.</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A tuple of the aggregate shape.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.lazy_aggregate">
<code class="descname">lazy_aggregate</code><span class="sig-paren">(</span><em>data</em>, <em>axis</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.lazy_aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform aggregation over the data with a lazy operation, analogous to
the &#8216;aggregate&#8217; result.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the &#8220;percent&#8221; keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>data (array):</dt>
<dd><p class="first last">A lazy array (<code class="xref py py-class docutils literal"><span class="pre">biggus.Array</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>axis (int or list of int):</dt>
<dd><p class="first last">The dimensions to aggregate over &#8211; note that this is defined
differently to the &#8216;aggregate&#8217; method &#8216;axis&#8217; argument, which only
accepts a single dimension index.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>kwargs:</dt>
<dd><p class="first last">All keyword arguments are passed through to the data aggregation
function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A lazy array representing the aggregation operation
(<code class="xref py py-class docutils literal"><span class="pre">biggus.Array</span></code>).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.name">
<code class="descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the aggregator.</p>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.post_process">
<code class="descname">post_process</code><span class="sig-paren">(</span><em>collapsed_cube</em>, <em>data_result</em>, <em>coords</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.post_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Returns a tuple(cube, weights) if a tuple(data, weights) was returned
from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>collapsed_cube:</dt>
<dd><p class="first last">A <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>data_result:</dt>
<dd><p class="first last">Result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coords:</dt>
<dd><p class="first last">The one or more coordinates that were aggregated over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the &#8220;weights&#8221;
keywords from a mean aggregator).</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The collapsed cube with it&#8217;s aggregated data payload. Or a tuple
pair of (cube, weights) if the keyword &#8220;returned&#8221; is specified
and True.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.update_metadata">
<code class="descname">update_metadata</code><span class="sig-paren">(</span><em>cube</em>, <em>coords</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.update_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Update cube cell method metadata w.r.t the aggregation function.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>cube (<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a>):</dt>
<dd><p class="first last">Source cube that requires metadata update.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coords (<a class="reference internal" href="coords.html#iris.coords.Coord" title="iris.coords.Coord"><code class="xref py py-class docutils literal"><span class="pre">iris.coords.Coord</span></code></a>):</dt>
<dd><p class="first last">The one or more coordinates that were aggregated.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li>This function is intended to be used in conjuction with aggregate()
and should be passed the same keywords (for example, the &#8220;ddof&#8221;
keyword for a standard deviation aggregator).</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.uses_weighting">
<code class="descname">uses_weighting</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.uses_weighting" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether this aggregator uses weighting.</p>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>kwargs:</dt>
<dd><p class="first last">Arguments to filter of weighted keywords.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd>Boolean.</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="function">
<dt id="iris.analysis.clear_phenomenon_identity">
<code class="descclassname">iris.analysis.</code><code class="descname">clear_phenomenon_identity</code><span class="sig-paren">(</span><em>cube</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.clear_phenomenon_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to clear the standard_name, attributes, and
cell_methods of a cube.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the linear interpolation and regridding scheme for
interpolating or regridding over one or more orthogonal coordinates,
typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> or
<a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.Linear">
<em class="property">class </em><code class="descclassname">iris.analysis.</code><code class="descname">Linear</code><span class="sig-paren">(</span><em>extrapolation_mode='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Linear interpolation and regridding scheme suitable for interpolating
or regridding over one or more orthogonal coordinates.</p>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>extrapolation_mode:</dt>
<dd><p class="first">Must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;extrapolate&#8217; or &#8216;linear&#8217; - The extrapolation points
will be calculated by extending the gradient of the
closest two points.</li>
<li>&#8216;nan&#8217; - The extrapolation points will be be set to NaN.</li>
<li>&#8216;error&#8217; - A ValueError exception will be raised, notifying an
attempt to extrapolate.</li>
<li>&#8216;mask&#8217; - The extrapolation points will always be masked, even
if the source data is not a MaskedArray.</li>
<li>&#8216;nanmask&#8217; - If the source data is a MaskedArray the
extrapolation points will be masked. Otherwise they will be
set to NaN.</li>
</ul>
</div></blockquote>
<p class="last">The default mode of extrapolation is &#8216;linear&#8217;.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.Linear.interpolator">
<code class="descname">interpolator</code><span class="sig-paren">(</span><em>cube</em>, <em>coords</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Linear.interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a linear interpolator to perform interpolation over the
given <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> specified by the dimensions of
the given coordinates.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> for
interpolating a cube. There are, however, some situations when
constructing your own interpolator is preferable. These are detailed
in the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-an-interpolator"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>cube:</dt>
<dd><p class="first last">The source <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a> to be interpolated.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coords:</dt>
<dd><p class="first last">The names or coordinate instances that are to be
interpolated over.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A callable with the interface:</p>
<blockquote>
<div><cite>callable(sample_points, collapse_scalar=True)</cite></div></blockquote>
<p>where <cite>sample_points</cite> is a sequence containing an array of values
for each of the coordinates passed to this method, and
<cite>collapse_scalar</cite> determines whether to remove length one
dimensions in the result cube caused by scalar values in
<cite>sample_points</cite>.</p>
<p>The values for coordinates that correspond to date/times
may optionally be supplied as datetime.datetime or
netcdftime.datetime instances.</p>
<p class="last">For example, for the callable returned by:
<cite>Linear().interpolator(cube, [&#8216;latitude&#8217;, &#8216;longitude&#8217;])</cite>,
sample_points must have the form
<cite>[new_lat_values, new_lon_values]</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Linear.regridder">
<code class="descname">regridder</code><span class="sig-paren">(</span><em>src_grid</em>, <em>target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Linear.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a linear regridder to perform regridding from the source
grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>src_grid:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>target_grid:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A callable with the interface:</p>
<blockquote>
<div><cite>callable(cube)</cite></div></blockquote>
<p class="last">where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="iris.analysis.Linear.LINEAR_EXTRAPOLATION_MODES">
<code class="descname">LINEAR_EXTRAPOLATION_MODES</code><em class="property"> = ['nanmask', 'mask', 'extrapolate', 'nan', 'error', 'linear']</em><a class="headerlink" href="#iris.analysis.Linear.LINEAR_EXTRAPOLATION_MODES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes an area-weighted regridding scheme for regridding
between &#8216;ordinary&#8217; horizontal grids with separated X and Y coordinates in a
common coordinate system.
Typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.AreaWeighted">
<em class="property">class </em><code class="descclassname">iris.analysis.</code><code class="descname">AreaWeighted</code><span class="sig-paren">(</span><em>mdtol=1</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.AreaWeighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Area-weighted regridding scheme suitable for regridding between
different orthogonal XY grids in the same coordinate system.</p>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>mdtol (float):</dt>
<dd><p class="first last">Tolerance of missing data. The value returned in each element of
the returned array will be masked if the fraction of missing data
exceeds mdtol. This fraction is calculated based on the area of
masked cells within each target cell. mdtol=0 means no masked
data is tolerated while mdtol=1 will mean the resulting element
will be masked if and only if all the overlapping elements of the
source grid are masked. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.AreaWeighted.regridder">
<code class="descname">regridder</code><span class="sig-paren">(</span><em>src_grid_cube</em>, <em>target_grid_cube</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.AreaWeighted.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an area-weighted regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>src_grid_cube:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>target_grid_cube:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A callable with the interface:</p>
<blockquote>
<div><cite>callable(cube)</cite></div></blockquote>
<p class="last">where <cite>cube</cite> is a cube with the same grid as <cite>src_grid_cube</cite>
that is to be regridded to the grid of <cite>target_grid_cube</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the nearest-neighbour interpolation and regridding
scheme for interpolating or regridding over one or more orthogonal
coordinates, typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.interpolate()</span></code></a>
or <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.Nearest">
<em class="property">class </em><code class="descclassname">iris.analysis.</code><code class="descname">Nearest</code><span class="sig-paren">(</span><em>extrapolation_mode='extrapolate'</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Nearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Nearest-neighbour interpolation and regridding scheme suitable for
interpolating or regridding over one or more orthogonal coordinates.</p>
<p>Kwargs:</p>
<ul>
<li><dl class="first docutils">
<dt>extrapolation_mode:</dt>
<dd><p class="first">Must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;extrapolate&#8217; - The extrapolation points will take their
value from the nearest source point.</li>
<li>&#8216;nan&#8217; - The extrapolation points will be be set to NaN.</li>
<li>&#8216;error&#8217; - A ValueError exception will be raised, notifying an
attempt to extrapolate.</li>
<li>&#8216;mask&#8217; - The extrapolation points will always be masked, even
if the source data is not a MaskedArray.</li>
<li>&#8216;nanmask&#8217; - If the source data is a MaskedArray the
extrapolation points will be masked. Otherwise they will be
set to NaN.</li>
</ul>
</div></blockquote>
<p class="last">The default mode of extrapolation is &#8216;extrapolate&#8217;.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.Nearest.interpolator">
<code class="descname">interpolator</code><span class="sig-paren">(</span><em>cube</em>, <em>coords</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Nearest.interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour interpolator to perform
interpolation over the given <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> specified
by the dimensions of the specified coordinates.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> for
interpolating a cube. There are, however, some situations when
constructing your own interpolator is preferable. These are detailed
in the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-an-interpolator"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>cube:</dt>
<dd><p class="first last">The source <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">iris.cube.Cube</span></code></a> to be interpolated.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coords:</dt>
<dd><p class="first last">The names or coordinate instances that are to be
interpolated over.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A callable with the interface:</p>
<blockquote>
<div><cite>callable(sample_points, collapse_scalar=True)</cite></div></blockquote>
<p>where <cite>sample_points</cite> is a sequence containing an array of values
for each of the coordinates passed to this method, and
<cite>collapse_scalar</cite> determines whether to remove length one
dimensions in the result cube caused by scalar values in
<cite>sample_points</cite>.</p>
<p>The values for coordinates that correspond to date/times
may optionally be supplied as datetime.datetime or
netcdftime.datetime instances.</p>
<p class="last">For example, for the callable returned by:
<cite>Nearest().interpolator(cube, [&#8216;latitude&#8217;, &#8216;longitude&#8217;])</cite>,
sample_points must have the form
<cite>[new_lat_values, new_lon_values]</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Nearest.regridder">
<code class="descname">regridder</code><span class="sig-paren">(</span><em>src_grid</em>, <em>target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Nearest.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>src_grid:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>target_grid:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A callable with the interface:</p>
<blockquote>
<div><cite>callable(cube)</cite></div></blockquote>
<p class="last">where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This is a nearest-neighbour regridding scheme for regridding data whose
horizontal (X- and Y-axis) coordinates are mapped to the <em>same</em> dimensions,
rather than being orthogonal on independent dimensions.</p>
<p>For latitude-longitude coordinates, the nearest-neighbour distances are
computed on the sphere, otherwise flat Euclidean distances are used.</p>
<p>The source X and Y coordinates can have any shape.</p>
<p>The target grid must be of the &#8220;normal&#8221; kind, i.e. it has separate,
1-dimensional X and Y coordinates.</p>
<p>Source and target XY coordinates must have the same coordinate system,
which may also be None.
If any of the XY coordinates are latitudes or longitudes, then they <em>all</em>
must be.  Otherwise, the corresponding X and Y coordinates must have the
same units in the source and grid cubes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only supports regridding, not interpolation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This scheme performs essentially the same job as
<a class="reference internal" href="experimental/regrid.html#iris.experimental.regrid.ProjectedUnstructuredNearest" title="iris.experimental.regrid.ProjectedUnstructuredNearest"><code class="xref py py-class docutils literal"><span class="pre">iris.experimental.regrid.ProjectedUnstructuredNearest</span></code></a>.
That scheme is faster, but only works well on data in a limited
region of the globe, covered by a specified projection.
This approach is more rigorously correct and can be applied to global
datasets.</p>
</div>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.UnstructuredNearest">
<em class="property">class </em><code class="descclassname">iris.analysis.</code><code class="descname">UnstructuredNearest</code><a class="headerlink" href="#iris.analysis.UnstructuredNearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Nearest-neighbour interpolation and regridding scheme suitable for
interpolating or regridding from un-gridded data such as trajectories
or other data where the X and Y coordinates share the same dimensions.</p>
<dl class="method">
<dt id="iris.analysis.UnstructuredNearest.regridder">
<code class="descname">regridder</code><span class="sig-paren">(</span><em>src_cube</em>, <em>target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.UnstructuredNearest.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder, of the
<a class="reference internal" href="analysis/trajectory.html#iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder" title="iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder"><code class="xref py py-class docutils literal"><span class="pre">UnstructuredNearestNeigbourRegridder</span></code></a>
type, to perform regridding from the source grid to the target grid.</p>
<p>This can then be applied to any source data with the same structure as
the original &#8216;src_cube&#8217;.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul>
<li><dl class="first docutils">
<dt>src_cube:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the source grid.
The X and Y coordinates can have any shape, but must be mapped over
the same cube dimensions.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>target_grid:</dt>
<dd><p class="first last">The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal"><span class="pre">Cube</span></code></a> defining the target grid.
The X and Y coordinates must be one-dimensional dimension
coordinates, mapped to different dimensions.
All other cube components are ignored.</p>
</dd>
</dl>
</li>
</ul>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A callable with the interface:</p>
<blockquote>
<div><cite>callable(cube)</cite></div></blockquote>
<p class="last">where <cite>cube</cite> is a cube with the same grid as <cite>src_cube</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="analysis/calculus.html" title="iris.analysis.calculus"
             >next</a> |</li>
        <li class="right" >
          <a href="TEST.html" title="iris.TEST"
             >previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../iris.html" >Iris reference documentation</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer">
    <p style="text-align: left; float: left; margin: 0px; padding: 0 0 0 5px;">Documentation licensed under the <a href="http://reference.data.gov.uk/id/open-government-licence" rel="license">Open Government Licence</a></p>
        &copy; <a href="../../copyright.html">British Crown Copyright</a> 2010 - 2014, Met Office
    </div>


  <!-- Include a version switcher to easily move between the documentation of different versions -->
  <script type=text/javascript src=/iris/docs/version_switch.js></script>
  </body>
</html>