
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>iris.analysis &#8212; Iris 2.3.0 documentation</title>
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="copyright" title="Copyright" href="../../copyright.html" />
    <link rel="next" title="iris.analysis.calculus" href="analysis/calculus.html" />
    <link rel="prev" title="Iris reference documentation" href="../iris.html" />
 
    <META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE"> 

    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <script type="text/javascript" src="https://docs.python.org/2/_static/copybutton.js"></script>

    <link rel="icon" type="image/png" sizes="32x32" href="../../_static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../_static/favicon-16x16.png">

    <link href="https://fonts.googleapis.com/css?family=Alike|Noto+Sans" rel="stylesheet">

  </head><body>

<a href="https://github.com/SciTools/iris">
    <img class="github-forkme" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
         alt="Fork Iris on GitHub" />
</a>


<div class="header-content">
    <a href="../../index.html">
        <img src="../../_static/Iris7_1_trim_100.png" alt="Iris logo" />
    </a>
    <div class="strapline">
      <h1>
          Iris <span class="version">v2.3</span>
      </h1>
      <p>
         A powerful, format-agnostic, community-driven Python library for analysing and
         visualising Earth science data.
      </p>
    </div>
</div>


    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="analysis/calculus.html" title="iris.analysis.calculus"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../iris.html" title="Iris reference documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../iris.html" accesskey="U">Iris reference documentation</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="../iris.html"
                        title="previous chapter">Iris reference documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="analysis/calculus.html"
                        title="next chapter">iris.analysis.calculus</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/iris/iris/analysis.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iris-analysis">
<span id="id1"></span><h1>iris.analysis<a class="headerlink" href="#iris-analysis" title="Permalink to this headline">Â¶</a></h1>
<div class="sidebar">
<p class="sidebar-title">Modules in this package</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="analysis/calculus.html">iris.analysis.calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/cartography.html">iris.analysis.cartography</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/geometry.html">iris.analysis.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/maths.html">iris.analysis.maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/stats.html">iris.analysis.stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysis/trajectory.html">iris.analysis.trajectory</a></li>
</ul>
</div>
</div>
<span class="target" id="module-iris.analysis"></span><p>A package providing <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> analysis support.</p>
<p>This module defines a suite of <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instances,
which are used to specify the statistical measure to calculate over a
<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, using methods such as
<a class="reference internal" href="cube.html#iris.cube.Cube.aggregated_by" title="iris.cube.Cube.aggregated_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregated_by()</span></code></a> and <a class="reference internal" href="cube.html#iris.cube.Cube.collapsed" title="iris.cube.Cube.collapsed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collapsed()</span></code></a>.</p>
<p>The <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> is a convenience class that allows
specific statistical aggregation operators to be defined and instantiated.
These operators can then be used to collapse, or partially collapse, one or
more dimensions of a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as discussed in
<a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics"><span class="std std-ref">Cube statistics</span></a>.</p>
<p>In particular, <a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics-collapsing"><span class="std std-ref">Collapsing entire data dimensions</span></a> discusses how to use
<a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-const docutils literal notranslate"><span class="pre">MEAN</span></code></a> to average over one dimension of a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>,
and also how to perform weighted <a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics-collapsing-average"><span class="std std-ref">Area averaging</span></a>.
While <a class="reference internal" href="../../userguide/cube_statistics.html#cube-statistics-aggregated-by"><span class="std std-ref">Partially reducing data dimensions</span></a> shows how to aggregate similar
groups of data points along a single dimension, to result in fewer points
in that dimension.</p>
<p>The gallery contains several interesting worked examples of how an
<a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> may be used, including:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="../../examples/Meteorology/COP_1d_plot.html#meteorology-cop-1d-plot"><span class="std std-ref">Global average annual temperature plot</span></a></p></li>
<li><p><a class="reference internal" href="../../examples/General/SOI_filtering.html#general-soi-filtering"><span class="std std-ref">Applying a filter to a time-series</span></a></p></li>
<li><p><a class="reference internal" href="../../examples/Meteorology/hovmoller.html#meteorology-hovmoller"><span class="std std-ref">Hovmoller diagram of monthly surface temperature</span></a></p></li>
<li><p><a class="reference internal" href="../../examples/Meteorology/lagged_ensemble.html#meteorology-lagged-ensemble"><span class="std std-ref">Seasonal ensemble model plots</span></a></p></li>
<li><p><a class="reference internal" href="../../examples/General/custom_aggregation.html#general-custom-aggregation"><span class="std std-ref">Calculating a custom statistic</span></a></p></li>
</ul>
</div></blockquote>
<p>In this module:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#iris.analysis.COUNT" title="iris.analysis.COUNT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">COUNT</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.GMEAN" title="iris.analysis.GMEAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GMEAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.HMEAN" title="iris.analysis.HMEAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HMEAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MAX" title="iris.analysis.MAX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAX</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MEAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MEDIAN" title="iris.analysis.MEDIAN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MEDIAN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.MIN" title="iris.analysis.MIN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MIN</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PEAK" title="iris.analysis.PEAK"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PEAK</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PERCENTILE" title="iris.analysis.PERCENTILE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PERCENTILE</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PROPORTION" title="iris.analysis.PROPORTION"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PROPORTION</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.RMS" title="iris.analysis.RMS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RMS</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.STD_DEV" title="iris.analysis.STD_DEV"><code class="xref py py-obj docutils literal notranslate"><span class="pre">STD_DEV</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.SUM" title="iris.analysis.SUM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SUM</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.VARIANCE" title="iris.analysis.VARIANCE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIANCE</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.WPERCENTILE" title="iris.analysis.WPERCENTILE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WPERCENTILE</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.coord_comparison" title="iris.analysis.coord_comparison"><code class="xref py py-obj docutils literal notranslate"><span class="pre">coord_comparison</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Aggregator</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.WeightedAggregator" title="iris.analysis.WeightedAggregator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WeightedAggregator</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.clear_phenomenon_identity" title="iris.analysis.clear_phenomenon_identity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear_phenomenon_identity</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Linear</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nearest</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.UnstructuredNearest" title="iris.analysis.UnstructuredNearest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnstructuredNearest</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.analysis.PointInCell" title="iris.analysis.PointInCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PointInCell</span></code></a></p></li>
</ul>
</div></blockquote>
<dl class="data">
<dt id="iris.analysis.COUNT">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">COUNT</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.COUNT" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that counts the number
of <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> data occurrences that satisfy a particular
criterion, as defined by a user supplied <em>function</em>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>function (callable):</dt><dd><p>A function which converts an array of data values into a corresponding
array of True/False values.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the number of <em>ensemble members</em> with precipitation exceeding 10
(in cube data units) could be calculated with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;ensemble_member&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">COUNT</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The <a class="reference internal" href="#iris.analysis.PROPORTION" title="iris.analysis.PROPORTION"><code class="xref py py-func docutils literal notranslate"><span class="pre">PROPORTION()</span></code></a> aggregator.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.GMEAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">GMEAN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.GMEAN" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates the
geometric mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.gmean.html#scipy.stats.mstats.gmean" title="(in SciPy v1.4.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.gmean()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal geometric means over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">GMEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.HMEAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">HMEAN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.HMEAN" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates the
harmonic mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.hmean.html#scipy.stats.mstats.hmean" title="(in SciPy v1.4.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.hmean()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal harmonic mean over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">HMEAN</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The harmonic mean is only valid if all data values are greater
than zero.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MAX">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MAX</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.MAX" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the maximum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.max.html#numpy.ma.max" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.max()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal maximums over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MAX</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MEAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MEAN</code> &#x2192; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.MEAN" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the mean over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.average.html#numpy.ma.average" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.average()</span></code></a>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned in each element of the
returned array will be masked if the fraction of masked data contributing
to that element exceeds mdtol. This fraction is calculated based on the
number of masked elements. mdtol=0 means no missing data is tolerated
while mdtol=1 means the resulting element will be masked if and only if
all the contributing elements are masked. Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube or the length of the window
for rolling window operations. Note that, latitude/longitude area
weights can be calculated using
<a class="reference internal" href="analysis/cartography.html#iris.analysis.cartography.area_weights" title="iris.analysis.cartography.area_weights"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.cartography.area_weights()</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>returned (boolean):</dt><dd><p>Set this to True to indicate that the collapsed weights are to be
returned along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal means over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute a weighted area average:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">)</span>
<span class="n">collapsed_cube</span><span class="p">,</span> <span class="n">collapsed_weights</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span>
                                                   <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">,</span>
                                                   <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
                                                   <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lazy operation is supported, via <code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.ma.average()</span></code>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MEDIAN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MEDIAN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.MEDIAN" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the median over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.median.html#numpy.ma.median" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.median()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal medians over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEDIAN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.MIN">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">MIN</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.MIN" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the minimum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.min.html#numpy.ma.min" title="(in NumPy v1.17)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.min()</span></code></a>.</p>
<p><strong>For example</strong>:</p>
<p>To compute zonal minimums over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MIN</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.PEAK">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PEAK</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.PEAK" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the peak value derived from a spline interpolation over a
<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>.</p>
<p>The peak calculation takes into account nan values. Therefore, if the number
of non-nan values is zero the result itself will be an array of nan values.</p>
<p>The peak calculation also takes into account masked values. Therefore, if the
number of non-masked values is zero the result itself will be a masked array.</p>
<p>If multiple coordinates are specified, then the peak calculations are
performed individually, in sequence, for each coordinate specified.</p>
<p><strong>For example</strong>:</p>
<p>To compute the peak over the <em>time</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PEAK</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.PERCENTILE">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PERCENTILE</code><a class="headerlink" href="#iris.analysis.PERCENTILE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">PercentileAggregator</span></code> instance that calculates the
percentile over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v1.4.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>percent (float or sequence of floats):</dt><dd><p>Percentile rank/s at which to extract value/s.</p>
</dd>
</dl>
</li>
</ul>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>alphap (float):</dt><dd><p>Plotting positions parameter, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v1.4.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>betap (float):</dt><dd><p>Plotting positions parameter, see <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mstats.mquantiles.html#scipy.stats.mstats.mquantiles" title="(in SciPy v1.4.0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.stats.mstats.mquantiles()</span></code></a>.
Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the 10th and 90th percentile over <em>time</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PERCENTILE</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">90</span><span class="p">])</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.PROPORTION">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PROPORTION</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.PROPORTION" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates the
proportion, as a fraction, of <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> data occurrences
that satisfy a particular criterion, as defined by a user supplied
<em>function</em>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>function (callable):</dt><dd><p>A function which converts an array of data values into a corresponding
array of True/False values.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the probability of precipitation exceeding 10
(in cube data units) across <em>ensemble members</em> could be calculated with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;ensemble_member&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PROPORTION</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Similarly, the proportion of <em>time</em> precipitation exceeded 10
(in cube data units) could be calculated with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">precip_cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">PROPORTION</span><span class="p">,</span>
                               <span class="n">function</span><span class="o">=</span><span class="k">lambda</span> <span class="n">values</span><span class="p">:</span> <span class="n">values</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The <a class="reference internal" href="#iris.analysis.COUNT" title="iris.analysis.COUNT"><code class="xref py py-func docutils literal notranslate"><span class="pre">COUNT()</span></code></a> aggregator.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.RMS">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">RMS</code> &#x2192; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.RMS" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the root mean square over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
((x0**2 + x1**2 + â¦ + xN-1**2) / N) ** 0.5.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube or the length of the window for
rolling window operations. The weights are applied to the squares when
taking the mean.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute the zonal root mean square over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">RMS</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.STD_DEV">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">STD_DEV</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.STD_DEV" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the standard deviation over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as
computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.std()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>ddof (integer):</dt><dd><p>Delta degrees of freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal standard deviations over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">STD_DEV</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the biased standard deviation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">STD_DEV</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lazy operation is supported, via <code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.nanstd()</span></code>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.SUM">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">SUM</code> &#x2192; WeightedAggregator instance.<a class="headerlink" href="#iris.analysis.SUM" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the sum over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.sum()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube, or the length of
the window for rolling window operations. Weights should be
normalized before using them with this aggregator if scaling
is not intended.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>returned (boolean):</dt><dd><p>Set this to True to indicate the collapsed weights are to be returned
along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute an accumulation over the <em>time</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
</pre></div>
</div>
<p>To compute a weighted rolling sum e.g. to apply a digital filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">4</span><span class="p">,</span> <span class="o">.</span><span class="mi">2</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">rolling_window</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span>
                             <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.VARIANCE">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">VARIANCE</code> &#x2192; Aggregator instance.<a class="headerlink" href="#iris.analysis.VARIANCE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> instance that calculates
the variance over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>, as computed by
<code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ma.var()</span></code>.</p>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>ddof (integer):</dt><dd><p>Delta degrees of freedom. The divisor used in calculations is N - ddof,
where N represents the number of elements. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<p><strong>For example</strong>:</p>
<p>To compute zonal variance over the <em>longitude</em> axis of a cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">)</span>
</pre></div>
</div>
<p>To obtain the biased variance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">VARIANCE</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lazy operation is supported, via <code class="xref py py-func docutils literal notranslate"><span class="pre">dask.array.nanvar()</span></code>.</p>
</div>
<p>This aggregator handles masked data.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="data">
<dt id="iris.analysis.WPERCENTILE">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">WPERCENTILE</code><a class="headerlink" href="#iris.analysis.WPERCENTILE" title="Permalink to this definition">Â¶</a></dt>
<dd><p>An <code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedPercentileAggregator</span></code> instance that
calculates the weighted percentile over a <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a>.</p>
<p><strong>Required</strong> kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>percent (float or sequence of floats):</dt><dd><p>Percentile rank/s at which to extract value/s.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>weights (float ndarray):</dt><dd><p>Weights matching the shape of the cube or the length of the window
for rolling window operations. Note that, latitude/longitude area
weights can be calculated using
<a class="reference internal" href="analysis/cartography.html#iris.analysis.cartography.area_weights" title="iris.analysis.cartography.area_weights"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.cartography.area_weights()</span></code></a>.</p>
</dd>
</dl>
</li>
</ul>
<p>Additional kwargs associated with the use of this aggregator:</p>
<ul class="simple">
<li><dl class="simple">
<dt>returned (boolean):</dt><dd><p>Set this to True to indicate that the collapsed weights are to be
returned along with the collapsed data. Defaults to False.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kind (string or int):</dt><dd><p>Specifies the kind of interpolation used, see
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.interpolate.interp1d()</span></code> Defaults to âlinearâ, which is
equivalent to alphap=0.5, betap=0.5 in <cite>iris.analysis.PERCENTILE</cite></p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="function">
<dt id="iris.analysis.coord_comparison">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">coord_comparison</code><span class="sig-paren">(</span><em class="sig-param">*cubes</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.coord_comparison" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convenience function to help compare coordinates on one or more cubes
by their metadata.</p>
<p>Return a dictionary where the key represents the statement,
âGiven these cubes list the coordinates which,
when grouped by metadata, are/haveâ¦â</p>
<p>Keys:</p>
<ul class="simple">
<li><dl class="simple">
<dt>grouped_coords</dt><dd><p>A list of coordinate groups of all the coordinates grouped together
by their coordinate definition</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ungroupable</dt><dd><p>A list of coordinate groups which contain at least one None,
meaning not all Cubes provide an equivalent coordinate</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>not_equal</dt><dd><p>A list of coordinate groups of which not all are equal
(superset of ungroupable)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>no_data_dimension</dt><dd><p>A list of coordinate groups of which all have no data dimensions on
their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>scalar</dt><dd><p>A list of coordinate groups of which all have shape (1, )</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>non_equal_data_dimension</dt><dd><p>A list of coordinate groups of which not all have the same
data dimension on their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>non_equal_shape</dt><dd><p>A list of coordinate groups of which not all have the same shape</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>equal_data_dimension</dt><dd><p>A list of coordinate groups of which all have the same data dimension
on their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>equal</dt><dd><p>A list of coordinate groups of which all are equal</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ungroupable_and_dimensioned</dt><dd><p>A list of coordinate groups of which not all cubes had an equivalent
(in metadata) coordinate which also describe a data dimension</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>dimensioned</dt><dd><p>A list of coordinate groups of which all describe a data dimension on
their respective cubes</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>ignorable</dt><dd><p>A list of scalar, ungroupable non_equal coordinate groups</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>resamplable</dt><dd><p>A list of equal, different data dimensioned coordinate groups</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>transposable</dt><dd><p>A list of non equal, same data dimensioned, non scalar coordinate groups</p>
</dd>
</dl>
</li>
</ul>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">coord_comparison</span><span class="p">(</span><span class="n">cube1</span><span class="p">,</span> <span class="n">cube2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;All equal coordinates: &#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;equal&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>The <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Aggregator</span></code></a> class provides common aggregation functionality.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.Aggregator">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">Aggregator</code><span class="sig-paren">(</span><em class="sig-param">cell_method</em>, <em class="sig-param">call_func</em>, <em class="sig-param">units_func=None</em>, <em class="sig-param">lazy_func=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis._Aggregator</span></code></p>
<p>Create an aggregator for the given <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code>.</p>
<p>Args:</p>
<ul>
<li><dl class="simple">
<dt>cell_method (string):</dt><dd><p>Cell method definition formatter.  Used in the fashion
âcell_method.format(**kwargs)â, to produce a cell-method string
which can include keyword values.</p>
</dd>
</dl>
</li>
<li><dl>
<dt>call_func (callable):</dt><dd><div class="line-block">
<div class="line"><em>Call signature</em>: (data, axis=None, **kwargs)</div>
</div>
<p>Data aggregation function.
Returns an aggregation result, collapsing the âaxisâ dimension of
the âdataâ argument.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul>
<li><dl>
<dt>units_func (callable):</dt><dd><div class="line-block">
<div class="line"><em>Call signature</em>: (units)</div>
</div>
<p>If provided, called to convert a cubeâs units.
Returns an <code class="xref py py-class docutils literal notranslate"><span class="pre">cf_units.Unit</span></code>, or a
value that can be made into one.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>lazy_func (callable or None):</dt><dd><p>An alternative to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> implementing a lazy
aggregation. Note that, it need not support all features of the
main operation, but should raise an error in unhandled cases.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Additional kwargs::</dt><dd><p>Passed through to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> and <code class="xref py py-data docutils literal notranslate"><span class="pre">lazy_func</span></code>.</p>
</dd>
</dl>
<p>Aggregators are used by cube aggregation methods such as
<a class="reference internal" href="cube.html#iris.cube.Cube.collapsed" title="iris.cube.Cube.collapsed"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collapsed()</span></code></a> and
<a class="reference internal" href="cube.html#iris.cube.Cube.aggregated_by" title="iris.cube.Cube.aggregated_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aggregated_by()</span></code></a>.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">cube</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">MEAN</span><span class="p">)</span>
</pre></div>
</div>
<p>A variety of ready-made aggregators are provided in this module, such
as <a class="reference internal" href="#iris.analysis.MEAN" title="iris.analysis.MEAN"><code class="xref py py-data docutils literal notranslate"><span class="pre">MEAN</span></code></a> and <a class="reference internal" href="#iris.analysis.MAX" title="iris.analysis.MAX"><code class="xref py py-data docutils literal notranslate"><span class="pre">MAX</span></code></a>.  Custom
aggregators can also be created for special purposes, see
<a class="reference internal" href="../../examples/General/custom_aggregation.html#general-custom-aggregation"><span class="std std-ref">Calculating a custom statistic</span></a> for a worked example.</p>
<dl class="method">
<dt id="iris.analysis.Aggregator.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.aggregate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Perform the aggregation function given the data.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the âpercentâ keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>Data array.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int):</dt><dd><p>Axis to aggregate over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned will be masked if
the fraction of data to missing data is less than or equal to
mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1
will return the resulting value from the aggregation function.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments apart from those specified above, are
passed through to the data aggregation function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>The aggregated data.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.aggregate_shape">
<code class="sig-name descname">aggregate_shape</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.aggregate_shape" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The shape of the new dimension/s created by the aggregator.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords.</p></li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>A tuple of the aggregate shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.lazy_aggregate">
<code class="sig-name descname">lazy_aggregate</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.lazy_aggregate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Perform aggregation over the data with a lazy operation, analogous to
the âaggregateâ result.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the âpercentâ keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>A lazy array (<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int or list of int):</dt><dd><p>The dimensions to aggregate over â note that this is defined
differently to the âaggregateâ method âaxisâ argument, which only
accepts a single dimension index.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments are passed through to the data aggregation
function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>A lazy array representing the aggregation operation
(<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the name of the aggregator.</p>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.post_process">
<code class="sig-name descname">post_process</code><span class="sig-paren">(</span><em class="sig-param">collapsed_cube</em>, <em class="sig-param">data_result</em>, <em class="sig-param">coords</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.post_process" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Process the result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>collapsed_cube:</dt><dd><p>A <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>data_result:</dt><dd><p>Result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The one or more coordinates that were aggregated over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the âddofâ
keyword from a standard deviation aggregator).</p></li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>The collapsed cube with its aggregated data payload.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Aggregator.update_metadata">
<code class="sig-name descname">update_metadata</code><span class="sig-paren">(</span><em class="sig-param">cube</em>, <em class="sig-param">coords</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Aggregator.update_metadata" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Update cube cell method metadata w.r.t the aggregation function.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube (<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>):</dt><dd><p>Source cube that requires metadata update.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords (<a class="reference internal" href="coords.html#iris.coords.Coord" title="iris.coords.Coord"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.coords.Coord</span></code></a>):</dt><dd><p>The one or more coordinates that were aggregated.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjuction with aggregate()
and should be passed the same keywords (for example, the âddofâ
keyword for a standard deviation aggregator).</p></li>
</ul>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>Convenience class that supports common weighted aggregation functionality.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.WeightedAggregator">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">WeightedAggregator</code><span class="sig-paren">(</span><em class="sig-param">cell_method</em>, <em class="sig-param">call_func</em>, <em class="sig-param">units_func=None</em>, <em class="sig-param">lazy_func=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#iris.analysis.Aggregator" title="iris.analysis.Aggregator"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Aggregator</span></code></a></p>
<p>Create a weighted aggregator for the given <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cell_method (string):</dt><dd><p>Cell method string that supports string format substitution.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>call_func (callable):</dt><dd><p>Data aggregation function. Call signature <cite>(data, axis, **kwargs)</cite>.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>units_func (callable):</dt><dd><p>Units conversion function.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>lazy_func (callable or None):</dt><dd><p>An alternative to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> implementing a lazy
aggregation. Note that, it need not support all features of the
main operation, but should raise an error in unhandled cases.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Additional kwargs:</dt><dd><p>Passed through to <code class="xref py py-data docutils literal notranslate"><span class="pre">call_func</span></code> and <code class="xref py py-data docutils literal notranslate"><span class="pre">lazy_func</span></code>.</p>
</dd>
</dl>
<dl class="method">
<dt id="iris.analysis.WeightedAggregator.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.aggregate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Perform the aggregation function given the data.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the âpercentâ keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>Data array.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int):</dt><dd><p>Axis to aggregate over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned will be masked if
the fraction of data to missing data is less than or equal to
mdtol.  mdtol=0 means no missing data is tolerated while mdtol=1
will return the resulting value from the aggregation function.
Defaults to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments apart from those specified above, are
passed through to the data aggregation function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>The aggregated data.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.aggregate_shape">
<code class="sig-name descname">aggregate_shape</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.aggregate_shape" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The shape of the new dimension/s created by the aggregator.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords.</p></li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>A tuple of the aggregate shape.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.lazy_aggregate">
<code class="sig-name descname">lazy_aggregate</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.lazy_aggregate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Perform aggregation over the data with a lazy operation, analogous to
the âaggregateâ result.</p>
<p>Keyword arguments are passed through to the data aggregation function
(for example, the âpercentâ keyword for a percentile aggregator).
This function is usually used in conjunction with update_metadata(),
which should be passed the same keyword arguments.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>data (array):</dt><dd><p>A lazy array (<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>axis (int or list of int):</dt><dd><p>The dimensions to aggregate over â note that this is defined
differently to the âaggregateâ method âaxisâ argument, which only
accepts a single dimension index.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>All keyword arguments are passed through to the data aggregation
function.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>A lazy array representing the aggregation operation
(<code class="xref py py-class docutils literal notranslate"><span class="pre">dask.array.Array</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.name" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the name of the aggregator.</p>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.post_process">
<code class="sig-name descname">post_process</code><span class="sig-paren">(</span><em class="sig-param">collapsed_cube</em>, <em class="sig-param">data_result</em>, <em class="sig-param">coords</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.post_process" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Process the result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Returns a tuple(cube, weights) if a tuple(data, weights) was returned
from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>collapsed_cube:</dt><dd><p>A <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>data_result:</dt><dd><p>Result from <a class="reference internal" href="#iris.analysis.Aggregator.aggregate" title="iris.analysis.Aggregator.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">iris.analysis.Aggregator.aggregate()</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The one or more coordinates that were aggregated over.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjunction with aggregate()
and should be passed the same keywords (for example, the âweightsâ
keywords from a mean aggregator).</p></li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>The collapsed cube with itâs aggregated data payload. Or a tuple
pair of (cube, weights) if the keyword âreturnedâ is specified
and True.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.update_metadata">
<code class="sig-name descname">update_metadata</code><span class="sig-paren">(</span><em class="sig-param">cube</em>, <em class="sig-param">coords</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.update_metadata" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Update cube cell method metadata w.r.t the aggregation function.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube (<a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a>):</dt><dd><p>Source cube that requires metadata update.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords (<a class="reference internal" href="coords.html#iris.coords.Coord" title="iris.coords.Coord"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.coords.Coord</span></code></a>):</dt><dd><p>The one or more coordinates that were aggregated.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><p>This function is intended to be used in conjuction with aggregate()
and should be passed the same keywords (for example, the âddofâ
keyword for a standard deviation aggregator).</p></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.WeightedAggregator.uses_weighting">
<code class="sig-name descname">uses_weighting</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.WeightedAggregator.uses_weighting" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Determine whether this aggregator uses weighting.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>kwargs:</dt><dd><p>Arguments to filter of weighted keywords.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>Boolean.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="function">
<dt id="iris.analysis.clear_phenomenon_identity">
<code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">clear_phenomenon_identity</code><span class="sig-paren">(</span><em class="sig-param">cube</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.clear_phenomenon_identity" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Helper function to clear the standard_name, attributes, and
cell_methods of a cube.</p>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the linear interpolation and regridding scheme for
interpolating or regridding over one or more orthogonal coordinates,
typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> or
<a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.Linear">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">Linear</code><span class="sig-paren">(</span><em class="sig-param">extrapolation_mode='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Linear" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Linear interpolation and regridding scheme suitable for interpolating
or regridding over one or more orthogonal coordinates.</p>
<p>Kwargs:</p>
<ul>
<li><dl>
<dt>extrapolation_mode:</dt><dd><p>Must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li><p>âextrapolateâ or âlinearâ - The extrapolation points
will be calculated by extending the gradient of the
closest two points.</p></li>
<li><p>ânanâ - The extrapolation points will be be set to NaN.</p></li>
<li><p>âerrorâ - A ValueError exception will be raised, notifying an
attempt to extrapolate.</p></li>
<li><p>âmaskâ - The extrapolation points will always be masked, even
if the source data is not a MaskedArray.</p></li>
<li><p>ânanmaskâ - If the source data is a MaskedArray the
extrapolation points will be masked. Otherwise they will be
set to NaN.</p></li>
</ul>
</div></blockquote>
<p>The default mode of extrapolation is âlinearâ.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.Linear.interpolator">
<code class="sig-name descname">interpolator</code><span class="sig-paren">(</span><em class="sig-param">cube</em>, <em class="sig-param">coords</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Linear.interpolator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a linear interpolator to perform interpolation over the
given <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> specified by the dimensions of
the given coordinates.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> for
interpolating a cube. There are, however, some situations when
constructing your own interpolator is preferable. These are detailed
in the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-an-interpolator"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube:</dt><dd><p>The source <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> to be interpolated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The names or coordinate instances that are to be
interpolated over.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(sample_points, collapse_scalar=True)</cite></p>
</div></blockquote>
<p>where <cite>sample_points</cite> is a sequence containing an array of values
for each of the coordinates passed to this method, and
<cite>collapse_scalar</cite> determines whether to remove length one
dimensions in the result cube caused by scalar values in
<cite>sample_points</cite>.</p>
<p>The values for coordinates that correspond to date/times
may optionally be supplied as datetime.datetime or
cftime.datetime instances.</p>
<p>For example, for the callable returned by:
<cite>Linear().interpolator(cube, [âlatitudeâ, âlongitudeâ])</cite>,
sample_points must have the form
<cite>[new_lat_values, new_lon_values]</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Linear.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_grid</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Linear.regridder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a linear regridder to perform regridding from the source
grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="iris.analysis.Linear.LINEAR_EXTRAPOLATION_MODES">
<code class="sig-name descname">LINEAR_EXTRAPOLATION_MODES</code><em class="property"> = ['extrapolate', 'error', 'nan', 'mask', 'nanmask', 'linear']</em><a class="headerlink" href="#iris.analysis.Linear.LINEAR_EXTRAPOLATION_MODES" title="Permalink to this definition">Â¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes an area-weighted regridding scheme for regridding
between âordinaryâ horizontal grids with separated X and Y coordinates in a
common coordinate system.
Typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.AreaWeighted">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">AreaWeighted</code><span class="sig-paren">(</span><em class="sig-param">mdtol=1</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.AreaWeighted" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Area-weighted regridding scheme suitable for regridding between
different orthogonal XY grids in the same coordinate system.</p>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol (float):</dt><dd><p>Tolerance of missing data. The value returned in each element of
the returned array will be masked if the fraction of missing data
exceeds mdtol. This fraction is calculated based on the area of
masked cells within each target cell. mdtol=0 means no masked
data is tolerated while mdtol=1 will mean the resulting element
will be masked if and only if all the overlapping elements of the
source grid are masked. Defaults to 1.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.AreaWeighted.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_grid_cube</em>, <em class="sig-param">target_grid_cube</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.AreaWeighted.regridder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates an area-weighted regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid_cube:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid_cube:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid_cube</cite>
that is to be regridded to the grid of <cite>target_grid_cube</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the nearest-neighbour interpolation and regridding
scheme for interpolating or regridding over one or more orthogonal
coordinates, typically for use with <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a>
or <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.Nearest">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">Nearest</code><span class="sig-paren">(</span><em class="sig-param">extrapolation_mode='extrapolate'</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Nearest" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Nearest-neighbour interpolation and regridding scheme suitable for
interpolating or regridding over one or more orthogonal coordinates.</p>
<p>Kwargs:</p>
<ul>
<li><dl>
<dt>extrapolation_mode:</dt><dd><p>Must be one of the following strings:</p>
<blockquote>
<div><ul class="simple">
<li><p>âextrapolateâ - The extrapolation points will take their
value from the nearest source point.</p></li>
<li><p>ânanâ - The extrapolation points will be be set to NaN.</p></li>
<li><p>âerrorâ - A ValueError exception will be raised, notifying an
attempt to extrapolate.</p></li>
<li><p>âmaskâ - The extrapolation points will always be masked, even
if the source data is not a MaskedArray.</p></li>
<li><p>ânanmaskâ - If the source data is a MaskedArray the
extrapolation points will be masked. Otherwise they will be
set to NaN.</p></li>
</ul>
</div></blockquote>
<p>The default mode of extrapolation is âextrapolateâ.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.Nearest.interpolator">
<code class="sig-name descname">interpolator</code><span class="sig-paren">(</span><em class="sig-param">cube</em>, <em class="sig-param">coords</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Nearest.interpolator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a nearest-neighbour interpolator to perform
interpolation over the given <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> specified
by the dimensions of the specified coordinates.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.interpolate()</span></code></a> for
interpolating a cube. There are, however, some situations when
constructing your own interpolator is preferable. These are detailed
in the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-an-interpolator"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>cube:</dt><dd><p>The source <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> to be interpolated.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>coords:</dt><dd><p>The names or coordinate instances that are to be
interpolated over.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(sample_points, collapse_scalar=True)</cite></p>
</div></blockquote>
<p>where <cite>sample_points</cite> is a sequence containing an array of values
for each of the coordinates passed to this method, and
<cite>collapse_scalar</cite> determines whether to remove length one
dimensions in the result cube caused by scalar values in
<cite>sample_points</cite>.</p>
<p>The values for coordinates that correspond to date/times
may optionally be supplied as datetime.datetime or
cftime.datetime instances.</p>
<p>For example, for the callable returned by:
<cite>Nearest().interpolator(cube, [âlatitudeâ, âlongitudeâ])</cite>,
sample_points must have the form
<cite>[new_lat_values, new_lon_values]</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="iris.analysis.Nearest.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_grid</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.Nearest.regridder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This is a nearest-neighbour regridding scheme for regridding data whose
horizontal (X- and Y-axis) coordinates are mapped to the <em>same</em> dimensions,
rather than being orthogonal on independent dimensions.</p>
<p>For latitude-longitude coordinates, the nearest-neighbour distances are
computed on the sphere, otherwise flat Euclidean distances are used.</p>
<p>The source X and Y coordinates can have any shape.</p>
<p>The target grid must be of the ânormalâ kind, i.e. it has separate,
1-dimensional X and Y coordinates.</p>
<p>Source and target XY coordinates must have the same coordinate system,
which may also be None.
If any of the XY coordinates are latitudes or longitudes, then they <em>all</em>
must be.  Otherwise, the corresponding X and Y coordinates must have the
same units in the source and grid cubes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently only supports regridding, not interpolation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This scheme performs essentially the same job as
<a class="reference internal" href="experimental/regrid.html#iris.experimental.regrid.ProjectedUnstructuredNearest" title="iris.experimental.regrid.ProjectedUnstructuredNearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.experimental.regrid.ProjectedUnstructuredNearest</span></code></a>.
That scheme is faster, but only works well on data in a limited
region of the globe, covered by a specified projection.
This approach is more rigorously correct and can be applied to global
datasets.</p>
</div>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.UnstructuredNearest">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">UnstructuredNearest</code><a class="headerlink" href="#iris.analysis.UnstructuredNearest" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Nearest-neighbour interpolation and regridding scheme suitable for
interpolating or regridding from un-gridded data such as trajectories
or other data where the X and Y coordinates share the same dimensions.</p>
<dl class="method">
<dt id="iris.analysis.UnstructuredNearest.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_cube</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.UnstructuredNearest.regridder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder, of the
<a class="reference internal" href="analysis/trajectory.html#iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder" title="iris.analysis.trajectory.UnstructuredNearestNeigbourRegridder"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnstructuredNearestNeigbourRegridder</span></code></a>
type, to perform regridding from the source grid to the target grid.</p>
<p>This can then be applied to any source data with the same structure as
the original âsrc_cubeâ.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_cube:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.
The X and Y coordinates can have any shape, but must be mapped over
the same cube dimensions.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.
The X and Y coordinates must be one-dimensional dimension
coordinates, mapped to different dimensions.
All other cube components are ignored.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_cube</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the point-in-cell regridding scheme for use
typically with <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<p>The PointInCell regridder can regrid data from a source grid of any
dimensionality and in any coordinate system.
The location of each source point is specified by X and Y coordinates
mapped over the same cube dimensions, aka âgrid dimensionsâ : the grid may
have any dimensionality.  The X and Y coordinates must also have the same,
defined coord_system.
The weights, if specified, must have the same shape as the X and Y
coordinates.
The output grid can be any ânormalâ XY grid, specified by <em>separate</em> X
and Y coordinates :  That is, X and Y have two different cube dimensions.
The output X and Y coordinates must also have a common, specified
coord_system.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.analysis.PointInCell">
<em class="property">class </em><code class="sig-prename descclassname">iris.analysis.</code><code class="sig-name descname">PointInCell</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.PointInCell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Point-in-cell regridding scheme suitable for regridding over one
or more orthogonal coordinates.</p>
<p>Optional Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights:</dt><dd><p>A <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> instance that defines the weights
for the grid cells of the source grid. Must have the same shape
as the data of the source grid.
If unspecified, equal weighting is assumed.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.analysis.PointInCell.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_grid</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.analysis.PointInCell.regridder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Creates a point-in-cell regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="analysis/calculus.html" title="iris.analysis.calculus"
             >next</a> |</li>
        <li class="right" >
          <a href="../iris.html" title="Iris reference documentation"
             >previous</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../iris.html" >Iris reference documentation</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer">
    <p style="text-align: left; float: left; margin: 0px; padding: 0 0 0 5px;">Documentation licensed under the <a href="http://reference.data.gov.uk/id/open-government-licence" rel="license">Open Government Licence</a></p>
        &copy; <a href="../../copyright.html">British Crown Copyright</a> 2010 - 2019, Met Office
    </div>

    <!-- Include a version switcher to easily move between the documentation of different versions -->
    <script type=text/javascript src="/iris/docs/version_switch.js" async></script>

  </body>
</html>