
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>8. Cube interpolation and regridding &#8212; Iris 2.2.0 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="9. Merge and Concatenate" href="merge_and_concat.html" />
    <link rel="prev" title="7. Plotting a cube" href="plotting_a_cube.html" />
 
    <META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE"> 

    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <script type="text/javascript" src="https://docs.python.org/2/_static/copybutton.js"></script>

    <link rel="icon" type="image/png" sizes="32x32" href="../_static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../_static/favicon-16x16.png">

    <link href="https://fonts.googleapis.com/css?family=Alike|Noto+Sans" rel="stylesheet">

  </head><body>

<a href="https://github.com/SciTools/iris">
    <img class="github-forkme" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
         alt="Fork Iris on GitHub" />
</a>


<div class="header-content">
    <a href="../index.html">
        <img src="../_static/Iris7_1_trim_100.png" alt="Iris logo" />
    </a>
    <div class="strapline">
      <h1>
          Iris <span class="version">v2.2</span>
      </h1>
      <p>
         A powerful, format-agnostic, community-driven Python library for analysing and
         visualising Earth science data.
      </p>
    </div>
</div>


    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="merge_and_concat.html" title="9. Merge and Concatenate"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="plotting_a_cube.html" title="7. Plotting a cube"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Iris user guide</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Cube interpolation and regridding</a><ul>
<li><a class="reference internal" href="#interpolation">8.1. Interpolation</a><ul>
<li><a class="reference internal" href="#interpolating-non-horizontal-coordinates">8.1.1. Interpolating non-horizontal coordinates</a></li>
<li><a class="reference internal" href="#caching-an-interpolator">8.1.2. Caching an interpolator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regridding">8.2. Regridding</a><ul>
<li><a class="reference internal" href="#area-weighted-regridding">8.2.1. Area-weighted regridding</a></li>
<li><a class="reference internal" href="#caching-a-regridder">8.2.2. Caching a regridder</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="plotting_a_cube.html"
                        title="previous chapter">7. Plotting a cube</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="merge_and_concat.html"
                        title="next chapter">9. Merge and Concatenate</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/userguide/interpolation_and_regridding.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <span class="target" id="interpolation-and-regridding"></span><div class="section" id="cube-interpolation-and-regridding">
<h1>8. Cube interpolation and regridding<a class="headerlink" href="#cube-interpolation-and-regridding" title="Permalink to this headline">¶</a></h1>
<p>Iris provides powerful cube-aware interpolation and regridding functionality,
exposed through Iris cube methods. This functionality is provided by building
upon existing interpolation schemes implemented by SciPy.</p>
<p>In Iris we refer to the avaliable types of interpolation and regridding as
<cite>schemes</cite>. The following are the interpolation schemes that are currently
available in Iris:</p>
<blockquote>
<div><ul class="simple">
<li>linear interpolation (<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Linear</span></code></a>), and</li>
<li>nearest-neighbour interpolation (<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Nearest</span></code></a>).</li>
</ul>
</div></blockquote>
<p>The following are the regridding schemes that are currently available in Iris:</p>
<blockquote>
<div><ul class="simple">
<li>linear regridding (<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Linear</span></code></a>),</li>
<li>nearest-neighbour regridding (<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Nearest</span></code></a>), and</li>
<li>area-weighted regridding (<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.AreaWeighted</span></code></a>, first-order conservative).</li>
</ul>
</div></blockquote>
<div class="section" id="interpolation">
<span id="id1"></span><h2>8.1. Interpolation<a class="headerlink" href="#interpolation" title="Permalink to this headline">¶</a></h2>
<p>Interpolating a cube is achieved with the <a class="reference internal" href="../iris/iris/cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a>
method. This method expects two arguments:</p>
<blockquote>
<div><ol class="arabic simple">
<li>the sample points to interpolate, and</li>
<li>the second argument being the interpolation scheme to use.</li>
</ol>
</div></blockquote>
<p>The result is a new cube, interpolated at the sample points.</p>
<p>Sample points must be defined as an iterable of <code class="docutils literal notranslate"><span class="pre">(coord,</span> <span class="pre">value(s))</span></code> pairs.
The <cite>coord</cite> argument can be either a coordinate name or coordinate instance.
The specified coordinate must exist on the cube being interpolated! For example:</p>
<blockquote>
<div><ul class="simple">
<li>coordinate names and scalar sample points: <code class="docutils literal notranslate"><span class="pre">[('latitude',</span> <span class="pre">51.48),</span> <span class="pre">('longitude',</span> <span class="pre">0)]</span></code>,</li>
<li>a coordinate instance and a scalar sample point: <code class="docutils literal notranslate"><span class="pre">[(cube.coord('latitude'),</span> <span class="pre">51.48)]</span></code>, and</li>
<li>a coordinate name and a NumPy array of sample points: <code class="docutils literal notranslate"><span class="pre">[('longitude',</span> <span class="pre">np.linspace(-11,</span> <span class="pre">2,</span> <span class="pre">14))]</span></code></li>
</ul>
</div></blockquote>
<p>are all examples of valid sample points.</p>
<p>The values for coordinates that correspond to date/times can be supplied as
datetime.datetime or cftime.datetime instances,
e.g. <code class="docutils literal notranslate"><span class="pre">[('time',</span> <span class="pre">datetime.datetime(2009,</span> <span class="pre">11,</span> <span class="pre">19,</span> <span class="pre">10,</span> <span class="pre">30))]</span></code>).</p>
<p>Let’s take the air temperature cube we’ve seen previously:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">air_temp</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;air_temp.pp&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">air_temp</span><span class="p">)</span>
<span class="go">air_temperature / (K)               (latitude: 73; longitude: 96)</span>
<span class="go">     Dimension coordinates:</span>
<span class="go">          latitude                           x              -</span>
<span class="go">          longitude                          -              x</span>
<span class="go">     Scalar coordinates:</span>
<span class="go">          forecast_period: 6477 hours, bound=(-28083.0, 6477.0) hours</span>
<span class="go">          forecast_reference_time: 1998-03-01 03:00:00</span>
<span class="go">          pressure: 1000.0 hPa</span>
<span class="go">          time: 1998-12-01 00:00:00, bound=(1994-12-01 00:00:00, 1998-12-01 00:00:00)</span>
<span class="go">     Attributes:</span>
<span class="go">          STASH: m01s16i203</span>
<span class="go">          source: Data from Met Office Unified Model</span>
<span class="go">     Cell methods:</span>
<span class="go">          mean within years: time</span>
<span class="go">          mean over years: time</span>
</pre></div>
</div>
<p>We can interpolate specific values from the coordinates of the cube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_points</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="mf">51.48</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">air_temp</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">()))</span>
<span class="go">air_temperature / (K)               (scalar cube)</span>
<span class="go">     Scalar coordinates:</span>
<span class="go">          forecast_period: 6477 hours, bound=(-28083.0, 6477.0) hours</span>
<span class="go">          forecast_reference_time: 1998-03-01 03:00:00</span>
<span class="go">          latitude: 51.48 degrees</span>
<span class="go">          longitude: 0 degrees</span>
<span class="go">          pressure: 1000.0 hPa</span>
<span class="go">          time: 1998-12-01 00:00:00, bound=(1994-12-01 00:00:00, 1998-12-01 00:00:00)</span>
<span class="go">     Attributes:</span>
<span class="go">          STASH: m01s16i203</span>
<span class="go">          source: Data from Met Office Unified Model</span>
<span class="go">     Cell methods:</span>
<span class="go">          mean within years: time</span>
<span class="go">          mean over years: time</span>
</pre></div>
</div>
<p>As we can see, the resulting cube is scalar and has longitude and latitude coordinates with
the values defined in our sample points.</p>
<p>It isn’t necessary to specify sample points for every dimension, only those that you
wish to interpolate over:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">air_temp</span><span class="o">.</span><span class="n">interpolate</span><span class="p">([(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Original: &#39;</span> <span class="o">+</span> <span class="n">air_temp</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">Original: air_temperature / (K)               (latitude: 73; longitude: 96)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Interpolated: &#39;</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">Interpolated: air_temperature / (K)               (latitude: 73)</span>
</pre></div>
</div>
<p>The sample points for a coordinate can be an array of values. When multiple coordinates are
provided with arrays instead of scalar sample points, the coordinates on the resulting cube
will be orthogonal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_points</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">)),</span>
<span class="gp">... </span>                 <span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span>  <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">13</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">air_temp</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">air_temperature / (K)               (latitude: 13; longitude: 14)</span>
</pre></div>
</div>
<div class="section" id="interpolating-non-horizontal-coordinates">
<h3>8.1.1. Interpolating non-horizontal coordinates<a class="headerlink" href="#interpolating-non-horizontal-coordinates" title="Permalink to this headline">¶</a></h3>
<p>Interpolation in Iris is not limited to horizontal-spatial coordinates - any
coordinate satisfying the prerequisites of the chosen scheme may be interpolated
over.</p>
<p>For instance, the <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Linear</span></code></a> scheme requires 1D numeric,
monotonic, coordinates. Supposing we have a single column cube such as
the one defined below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;hybrid_height.nc&#39;</span><span class="p">),</span> <span class="s1">&#39;air_potential_temperature&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column</span> <span class="o">=</span> <span class="n">cube</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">air_potential_temperature / (K)     (model_level_number: 15)</span>
</pre></div>
</div>
<p>This cube has a “hybrid-height” vertical coordinate system, meaning that the vertical
coordinate is unevenly spaced in altitude:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;altitude&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
<span class="go">[ 418.69836  434.5705   456.7928   485.3665   520.2933   561.5752</span>
<span class="go">  609.2145   663.2141   723.57697  790.30664  863.4072   942.8823</span>
<span class="go"> 1028.737   1120.9764  1219.6051 ]</span>
</pre></div>
</div>
<p>We could regularise the vertical coordinate by defining 10 equally spaced altitude
sample points between 400 and 1250 and interpolating our vertical coordinate onto
these sample points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_points</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;altitude&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">1250</span><span class="p">,</span> <span class="mi">10</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">new_column</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">air_potential_temperature / (K)     (model_level_number: 10)</span>
</pre></div>
</div>
<p>Let’s look at the original data, the interpolation line and
the new data in a plot. This will help us to see what is going on:</p>
<p>(<a class="reference external" href="../userguide/regridding_plots/interpolate_column.py">Source code</a>, <a class="reference external" href="../userguide/regridding_plots/interpolate_column.png">png</a>)</p>
<div class="figure" id="interpolate-column">
<img alt="../_images/interpolate_column.png" src="../_images/interpolate_column.png" />
</div>
<p>The red diamonds on the extremes of the altitude values show that we have
extrapolated data beyond the range of the original data. In some cases this is
desirable but in other cases it is not. For example, this column defines
a surface altitude value of 414m, so extrapolating an “air potential temperature”
at 400m makes little physical sense in this case.</p>
<p>We can control the extrapolation mode when defining the interpolation scheme.
Controlling the extrapolation mode allows us to avoid situations like the above where
extrapolating values makes little physical sense.</p>
<p>The extrapolation mode is controlled by the <code class="docutils literal notranslate"><span class="pre">extrapolation_mode</span></code> keyword.
For the available interpolation schemes available in Iris, the <code class="docutils literal notranslate"><span class="pre">extrapolation_mode</span></code>
keyword must be one of:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">extrapolate</span></code> – the extrapolation points will be calculated by extending the gradient of the closest two points,</li>
<li><code class="docutils literal notranslate"><span class="pre">error</span></code> – a ValueError exception will be raised, notifying an attempt to extrapolate,</li>
<li><code class="docutils literal notranslate"><span class="pre">nan</span></code> – the extrapolation points will be be set to NaN,</li>
<li><code class="docutils literal notranslate"><span class="pre">mask</span></code> – the extrapolation points will always be masked, even if the source data is not a MaskedArray, or</li>
<li><code class="docutils literal notranslate"><span class="pre">nanmask</span></code> – if the source data is a MaskedArray the extrapolation points will be masked. Otherwise they will be set to NaN.</li>
</ul>
</div></blockquote>
<p>Using an extrapolation mode is achieved by constructing an interpolation scheme
with the extrapolation mode keyword set as required. The constructed scheme
is then passed to the <a class="reference internal" href="../iris/iris/cube.html#iris.cube.Cube.interpolate" title="iris.cube.Cube.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a> method.
For example, to mask values that lie beyond the range of the original data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">extrapolation_mode</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">scheme</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">new_column</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;altitude&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
<span class="go">[       nan  494.44452  588.8889   683.33325  777.77783  872.2222</span>
<span class="go">  966.66675 1061.1111  1155.5554         nan]</span>
</pre></div>
</div>
</div>
<div class="section" id="caching-an-interpolator">
<span id="id2"></span><h3>8.1.2. Caching an interpolator<a class="headerlink" href="#caching-an-interpolator" title="Permalink to this headline">¶</a></h3>
<p>If you need to interpolate a cube on multiple sets of sample points you can
‘cache’ an interpolator to be used for each of these interpolations. This can
shorten the execution time of your code as the most computationally
intensive part of an interpolation is setting up the interpolator.</p>
<p>To cache an interpolator you must set up an interpolator scheme and call the
scheme’s interpolator method. The interpolator method takes as arguments:</p>
<blockquote>
<div><ol class="arabic simple">
<li>a cube to be interpolated, and</li>
<li>an iterable of coordinate names or coordinate instances of the coordinates that are to be interpolated over.</li>
</ol>
</div></blockquote>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">air_temp</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;air_temp.pp&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Nearest</span><span class="p">()</span><span class="o">.</span><span class="n">interpolator</span><span class="p">(</span><span class="n">air_temp</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span> <span class="s1">&#39;longitude&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>When this cached interpolator is called you must pass it an iterable of sample points
that have the same form as the iterable of coordinates passed to the constructor.
So, to use the cached interpolator defined above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">latitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">48</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">longitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">latitudes</span><span class="p">,</span> <span class="n">longitudes</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">([</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">])</span>
</pre></div>
</div>
<p>In each case <code class="docutils literal notranslate"><span class="pre">result</span></code> will be a cube interpolated from the <code class="docutils literal notranslate"><span class="pre">air_temp</span></code> cube we
passed to interpolator.</p>
<p>Note that you must specify the required extrapolation mode when setting up the cached interpolator.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Nearest</span><span class="p">(</span><span class="n">extrapolation_mode</span><span class="o">=</span><span class="s1">&#39;nan&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">interpolator</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="regridding">
<span id="id3"></span><h2>8.2. Regridding<a class="headerlink" href="#regridding" title="Permalink to this headline">¶</a></h2>
<p>Regridding is conceptually a very similar process to interpolation in Iris.
The primary difference is that interpolation is based on sample points, while
regridding is based on the <strong>horizontal</strong> grid of <em>another cube</em>.</p>
<p>Regridding a cube is achieved with the <a class="reference internal" href="../iris/iris/cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cube.regrid()</span></code></a> method.
This method expects two arguments:</p>
<blockquote>
<div><ol class="arabic simple">
<li><em>another cube</em> that defines the target grid onto which the cube should be regridded, and</li>
<li>the regridding scheme to use.</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Regridding is a common operation needed to allow comparisons of data on different grids.
The powerful mapping functionality provided by cartopy, however, means that regridding
is often not necessary if performed just for visualisation purposes.</p>
</div>
<p>Let’s load two cubes that have different grids and coordinate systems:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">global_air_temp</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;air_temp.pp&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotated_psl</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;rotated_pole.nc&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>We can visually confirm that they are on different grids by plotting the two cubes:</p>
<p>(<a class="reference external" href="../userguide/regridding_plots/regridding_plot.py">Source code</a>, <a class="reference external" href="../userguide/regridding_plots/regridding_plot.png">png</a>)</p>
<div class="figure" id="regridding-plot">
<img alt="../_images/regridding_plot.png" src="../_images/regridding_plot.png" />
</div>
<p>Let’s regrid the <code class="docutils literal notranslate"><span class="pre">global_air_temp</span></code> cube onto a rotated pole grid
using a linear regridding scheme. To achieve this we pass the <code class="docutils literal notranslate"><span class="pre">rotated_psl</span></code>
cube to the regridder to supply the target grid to regrid the <code class="docutils literal notranslate"><span class="pre">global_air_temp</span></code>
cube onto:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rotated_air_temp</span> <span class="o">=</span> <span class="n">global_air_temp</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">rotated_psl</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">())</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../userguide/regridding_plots/regridded_to_rotated.py">Source code</a>, <a class="reference external" href="../userguide/regridding_plots/regridded_to_rotated.png">png</a>)</p>
<div class="figure" id="regridded-to-rotated">
<img alt="../_images/regridded_to_rotated.png" src="../_images/regridded_to_rotated.png" />
</div>
<p>We could regrid the pressure values onto the global grid, but this will involve
some form of extrapolation. As with interpolation, we can control the extrapolation
mode when defining the regridding scheme.</p>
<p>For the available regridding schemes in Iris, the <code class="docutils literal notranslate"><span class="pre">extrapolation_mode</span></code> keyword
must be one of:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">extrapolate</span></code> –</p>
<blockquote>
<div><ul class="simple">
<li>for <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">Linear</span></code></a> the extrapolation points will be calculated by extending the gradient of the closest two points.</li>
<li>for <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nearest</span></code></a> the extrapolation points will take their value from the nearest source point.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">nan</span></code> – the extrapolation points will be be set to NaN.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">error</span></code> – a ValueError exception will be raised, notifying an attempt to extrapolate.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">mask</span></code> – the extrapolation points will always be masked, even if the source data is not a MaskedArray.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">nanmask</span></code> – if the source data is a MaskedArray the extrapolation points will be masked. Otherwise they will be set to NaN.</p>
</li>
</ul>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">rotated_psl</span></code> cube is defined on a limited area rotated pole grid. If we regridded
the <code class="docutils literal notranslate"><span class="pre">rotated_psl</span></code> cube onto the global grid as defined by the <code class="docutils literal notranslate"><span class="pre">global_air_temp</span></code> cube
any linearly extrapolated values would quickly become dominant and highly inaccurate.
We can control this behaviour by defining the <code class="docutils literal notranslate"><span class="pre">extrapolation_mode</span></code> in the constructor
of the regridding scheme to mask values that lie outside of the domain of the rotated
pole grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">extrapolation_mode</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">global_psl</span> <span class="o">=</span> <span class="n">rotated_psl</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">global_air_temp</span><span class="p">,</span> <span class="n">scheme</span><span class="p">)</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../userguide/regridding_plots/regridded_to_global.py">Source code</a>, <a class="reference external" href="../userguide/regridding_plots/regridded_to_global.png">png</a>)</p>
<div class="figure" id="regridded-to-global">
<img alt="../_images/regridded_to_global.png" src="../_images/regridded_to_global.png" />
</div>
<p>Notice that although we can still see the approximate shape of the rotated pole grid, the
cells have now become rectangular in a plate carrée (equirectangular) projection.
The spatial grid of the resulting cube is really global, with a large proportion of the
data being masked.</p>
<div class="section" id="area-weighted-regridding">
<h3>8.2.1. Area-weighted regridding<a class="headerlink" href="#area-weighted-regridding" title="Permalink to this headline">¶</a></h3>
<p>It is often the case that a point-based regridding scheme (such as
<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Linear</span></code></a> or <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.Nearest</span></code></a>) is not
appropriate when you need to conserve quantities when regridding. The
<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.AreaWeighted</span></code></a> scheme is less general than
<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Linear" title="iris.analysis.Linear"><code class="xref py py-class docutils literal notranslate"><span class="pre">Linear</span></code></a> or <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.Nearest" title="iris.analysis.Nearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nearest</span></code></a>, but is a
conservative regridding scheme, meaning that the area-weighted total is
approximately preserved across grids.</p>
<p>With the <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a> regridding scheme, each target grid-box’s
data is computed as a weighted mean of all grid-boxes from the source grid. The weighting
for any given target grid-box is the area of the intersection with each of the
source grid-boxes. This scheme performs well when regridding from a high
resolution source grid to a lower resolution target grid, since all source data
points will be accounted for in the target grid.</p>
<p>Let’s demonstrate this with the global air temperature cube we saw previously,
along with a limited area cube containing total concentration of volcanic ash:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">global_air_temp</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;air_temp.pp&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">global_air_temp</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">air_temperature / (K)               (latitude: 73; longitude: 96)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regional_ash</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;NAME_output.txt&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regional_ash</span> <span class="o">=</span> <span class="n">regional_ash</span><span class="o">.</span><span class="n">collapsed</span><span class="p">(</span><span class="s1">&#39;flight_level&#39;</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">regional_ash</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">VOLCANIC_ASH_AIR_CONCENTRATION / (g/m3) (latitude: 214; longitude: 584)</span>
</pre></div>
</div>
<p>One of the key limitations of the <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a>
regridding scheme is that the two input grids must be defined in the same
coordinate system as each other. Both input grids must also contain monotonic,
bounded, 1D spatial coordinates.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a> regridding scheme requires spatial
areas, therefore the longitude and latitude coordinates must be bounded.
If the longitude and latitude bounds are not defined in the cube we can
guess the bounds based on the coordinates’ point values:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">global_air_temp</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">global_air_temp</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">guess_bounds</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>Using NumPy’s masked array module we can mask any data that falls below a meaningful
concentration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regional_ash</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_less</span><span class="p">(</span><span class="n">regional_ash</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mf">5e-6</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we can regrid the data using the <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a>
regridding scheme:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scheme</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">AreaWeighted</span><span class="p">(</span><span class="n">mdtol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">global_ash</span> <span class="o">=</span> <span class="n">regional_ash</span><span class="o">.</span><span class="n">regrid</span><span class="p">(</span><span class="n">global_air_temp</span><span class="p">,</span> <span class="n">scheme</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">global_ash</span><span class="o">.</span><span class="n">summary</span><span class="p">(</span><span class="n">shorten</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">VOLCANIC_ASH_AIR_CONCENTRATION / (g/m3) (latitude: 73; longitude: 96)</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a> regridding scheme allows us
to define a missing data tolerance (<code class="docutils literal notranslate"><span class="pre">mdtol</span></code>), which specifies the tolerated
fraction of masked data in any given target grid-box. If the fraction of masked
data within a target grid-box exceeds this value, the data in this target
grid-box will be masked in the result.</p>
<p>The fraction of masked data is calculated based on the area of masked source
grid-boxes that overlaps with each target grid-box. Defining an <code class="docutils literal notranslate"><span class="pre">mdtol</span></code> in the
<a class="reference internal" href="../iris/iris/analysis.html#iris.analysis.AreaWeighted" title="iris.analysis.AreaWeighted"><code class="xref py py-class docutils literal notranslate"><span class="pre">AreaWeighted</span></code></a> regridding scheme allows fine control
of masked data tolerance. It is worth remembering that defining an <code class="docutils literal notranslate"><span class="pre">mdtol</span></code> of
anything other than 1 will prevent the scheme from being fully conservative, as
some data will be disregarded if it lies close to masked data.</p>
<p>To visualise the above regrid, let’s plot the original data, along with 3 distinct
<code class="docutils literal notranslate"><span class="pre">mdtol</span></code> values to compare the result:</p>
<p>(<a class="reference external" href="../userguide/regridding_plots/regridded_to_global_area_weighted.py">Source code</a>, <a class="reference external" href="../userguide/regridding_plots/regridded_to_global_area_weighted.png">png</a>)</p>
<div class="figure" id="regridded-to-global-area-weighted">
<img alt="../_images/regridded_to_global_area_weighted.png" src="../_images/regridded_to_global_area_weighted.png" />
</div>
</div>
<div class="section" id="caching-a-regridder">
<span id="id4"></span><h3>8.2.2. Caching a regridder<a class="headerlink" href="#caching-a-regridder" title="Permalink to this headline">¶</a></h3>
<p>If you need to regrid multiple cubes with a common source grid onto a common
target grid you can ‘cache’ a regridder to be used for each of these regrids.
This can shorten the execution time of your code as the most computationally
intensive part of a regrid is setting up the regridder.</p>
<p>To cache a regridder you must set up a regridder scheme and call the
scheme’s regridder method. The regridder method takes as arguments:</p>
<blockquote>
<div><ol class="arabic simple">
<li>a cube (that is to be regridded) defining the source grid, and</li>
<li>a cube defining the target grid to regrid the source cube to.</li>
</ol>
</div></blockquote>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">global_air_temp</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;air_temp.pp&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotated_psl</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">load_cube</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">sample_data_path</span><span class="p">(</span><span class="s1">&#39;rotated_pole.nc&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regridder</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">Nearest</span><span class="p">()</span><span class="o">.</span><span class="n">regridder</span><span class="p">(</span><span class="n">global_air_temp</span><span class="p">,</span> <span class="n">rotated_psl</span><span class="p">)</span>
</pre></div>
</div>
<p>When this cached regridder is called you must pass it a cube on the same grid
as the source grid cube (in this case <code class="docutils literal notranslate"><span class="pre">global_air_temp</span></code>) that is to be
regridded to the target grid. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">cube</span> <span class="ow">in</span> <span class="n">list_of_cubes_on_source_grid</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">result</span> <span class="o">=</span> <span class="n">regridder</span><span class="p">(</span><span class="n">cube</span><span class="p">)</span>
</pre></div>
</div>
<p>In each case <code class="docutils literal notranslate"><span class="pre">result</span></code> will be the input cube regridded to the grid defined by
the target grid cube (in this case <code class="docutils literal notranslate"><span class="pre">rotated_psl</span></code>) that we used to define the
cached regridder.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="merge_and_concat.html" title="9. Merge and Concatenate"
             >next</a> |</li>
        <li class="right" >
          <a href="plotting_a_cube.html" title="7. Plotting a cube"
             >previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="index.html" >Iris user guide</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer">
    <p style="text-align: left; float: left; margin: 0px; padding: 0 0 0 5px;">Documentation licensed under the <a href="http://reference.data.gov.uk/id/open-government-licence" rel="license">Open Government Licence</a></p>
        &copy; <a href="../copyright.html">British Crown Copyright</a> 2010 - 2018, Met Office
    </div>

    <!-- Include a version switcher to easily move between the documentation of different versions -->
    <script type=text/javascript src="/iris/docs/version_switch.js" async></script>

  </body>
</html>