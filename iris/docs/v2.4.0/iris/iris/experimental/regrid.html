
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>iris.experimental.regrid &#8212; Iris 2.2.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="copyright" title="Copyright" href="../../../copyright.html" />
    <link rel="next" title="iris.experimental.regrid_conservative" href="regrid_conservative.html" />
    <link rel="prev" title="iris.experimental.raster" href="raster.html" />
 
    <META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE"> 

    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <script type="text/javascript" src="https://docs.python.org/2/_static/copybutton.js"></script>

    <link rel="icon" type="image/png" sizes="32x32" href="../../../_static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../_static/favicon-16x16.png">

    <link href="https://fonts.googleapis.com/css?family=Alike|Noto+Sans" rel="stylesheet">

  </head><body>

<a href="https://github.com/SciTools/iris">
    <img class="github-forkme" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"
         alt="Fork Iris on GitHub" />
</a>


<div class="header-content">
    <a href="../../../index.html">
        <img src="../../../_static/Iris7_1_trim_100.png" alt="Iris logo" />
    </a>
    <div class="strapline">
      <h1>
          Iris <span class="version">v2.4</span>
      </h1>
      <p>
         A powerful, format-agnostic, community-driven Python library for analysing and
         visualising Earth science data.
      </p>
    </div>
</div>


    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="regrid_conservative.html" title="iris.experimental.regrid_conservative"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="raster.html" title="iris.experimental.raster"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../iris.html" >Iris reference documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../experimental.html" accesskey="U">iris.experimental</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="raster.html"
                        title="previous chapter">iris.experimental.raster</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="regrid_conservative.html"
                        title="next chapter">iris.experimental.regrid_conservative</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/iris/iris/experimental/regrid.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iris-experimental-regrid">
<span id="id1"></span><h1>iris.experimental.regrid<a class="headerlink" href="#iris-experimental-regrid" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-iris.experimental.regrid"></span><p>Regridding functions.</p>
<p>In this module:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#iris.experimental.regrid.regrid_area_weighted_rectilinear_src_and_grid" title="iris.experimental.regrid.regrid_area_weighted_rectilinear_src_and_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrid_area_weighted_rectilinear_src_and_grid</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.experimental.regrid.regrid_weighted_curvilinear_to_rectilinear" title="iris.experimental.regrid.regrid_weighted_curvilinear_to_rectilinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regrid_weighted_curvilinear_to_rectilinear</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.experimental.regrid.PointInCell" title="iris.experimental.regrid.PointInCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PointInCell</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.experimental.regrid.ProjectedUnstructuredLinear" title="iris.experimental.regrid.ProjectedUnstructuredLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectedUnstructuredLinear</span></code></a></p></li>
<li><p><a class="reference internal" href="#iris.experimental.regrid.ProjectedUnstructuredNearest" title="iris.experimental.regrid.ProjectedUnstructuredNearest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ProjectedUnstructuredNearest</span></code></a></p></li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="iris.experimental.regrid.regrid_area_weighted_rectilinear_src_and_grid">
<code class="sig-prename descclassname">iris.experimental.regrid.</code><code class="sig-name descname">regrid_area_weighted_rectilinear_src_and_grid</code><span class="sig-paren">(</span><em class="sig-param">src_cube</em>, <em class="sig-param">grid_cube</em>, <em class="sig-param">mdtol=0</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.regrid_area_weighted_rectilinear_src_and_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new cube with data values calculated using the area weighted
mean of data values from src_grid regridded onto the horizontal grid of
grid_cube.</p>
<p>This function requires that the horizontal grids of both cubes are
rectilinear (i.e. expressed in terms of two orthogonal 1D coordinates)
and that these grids are in the same coordinate system. This function
also requires that the coordinates describing the horizontal grids
all have bounds.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Elements in data array of the returned cube that lie either partially
or entirely outside of the horizontal extent of the src_cube will
be masked irrespective of the value of mdtol.</p>
</div>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_cube:</dt><dd><p>An instance of <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> that supplies the data,
metadata and coordinates.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>grid_cube:</dt><dd><p>An instance of <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> that supplies the desired
horizontal grid definition.</p>
</dd>
</dl>
</li>
</ul>
<p>Kwargs:</p>
<ul class="simple">
<li><dl class="simple">
<dt>mdtol:</dt><dd><p>Tolerance of missing data. The value returned in each element of the
returned cube’s data array will be masked if the fraction of masked
data in the overlapping cells of the source cube exceeds mdtol. This
fraction is calculated based on the area of masked cells within each
target cell. mdtol=0 means no missing data is tolerated while mdtol=1
will mean the resulting element will be masked if and only if all the
overlapping cells of the source cube are masked. Defaults to 0.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>A new <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><dl class="function">
<dt id="iris.experimental.regrid.regrid_weighted_curvilinear_to_rectilinear">
<code class="sig-prename descclassname">iris.experimental.regrid.</code><code class="sig-name descname">regrid_weighted_curvilinear_to_rectilinear</code><span class="sig-paren">(</span><em class="sig-param">src_cube</em>, <em class="sig-param">weights</em>, <em class="sig-param">grid_cube</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.regrid_weighted_curvilinear_to_rectilinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new cube with the data values calculated using the weighted
mean of data values from <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> and the weights from
<code class="xref py py-data docutils literal notranslate"><span class="pre">weights</span></code> regridded onto the horizontal grid of <code class="xref py py-data docutils literal notranslate"><span class="pre">grid_cube</span></code>.</p>
<p>This function requires that the <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> has a horizontal grid
defined by a pair of X- and Y-axis coordinates which are mapped over the
same cube dimensions, thus each point has an individually defined X and
Y coordinate value.  The actual dimensions of these coordinates are of
no significance.
The <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> grid cube must have a normal horizontal grid,
i.e. expressed in terms of two orthogonal 1D horizontal coordinates.
Both grids must be in the same coordinate system, and the <code class="xref py py-data docutils literal notranslate"><span class="pre">grid_cube</span></code>
must have horizontal coordinates that are both bounded and contiguous.</p>
<p>Note that, for any given target <code class="xref py py-data docutils literal notranslate"><span class="pre">grid_cube</span></code> cell, only the points
from the <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> that are bound by that cell will contribute to
the cell result. The bounded extent of the <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> will not be
considered here.</p>
<p>A target <code class="xref py py-data docutils literal notranslate"><span class="pre">grid_cube</span></code> cell result will be calculated as,
<img class="math" src="../../../_images/math/509054e166c4d9c99278443faa81c66310b5a6a6.png" alt="\sum (src\_cube.data_{ij} * weights_{ij}) / \sum weights_{ij}"/>, for
all <img class="math" src="../../../_images/math/f74aad8964771b511e9a790f647540df832ad360.png" alt="ij"/> <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> points that are bound by that cell.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ul class="simple">
<li><p>All coordinates that span the <code class="xref py py-data docutils literal notranslate"><span class="pre">src_cube</span></code> that don’t define
the horizontal curvilinear grid will be ignored.</p></li>
</ul>
</div>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_cube:</dt><dd><p>A <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> instance that defines the source
variable grid to be regridded.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>weights (array or None):</dt><dd><p>A <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> instance that defines the weights
for the source variable grid cells. Must have the same shape
as the X and Y coordinates.  If weights is None, all-ones will be used.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>grid_cube:</dt><dd><p>A <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> instance that defines the target
rectilinear grid.</p>
</dd>
</dl>
</li>
</ul>
<dl class="simple">
<dt>Returns:</dt><dd><p>A <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.cube.Cube</span></code></a> instance.</p>
</dd>
</dl>
</dd></dl>

<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the point-in-cell regridding scheme for use
typically with <a class="reference internal" href="../cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a>.</p>
<p>The PointInCell regridder can regrid data from a source grid of any
dimensionality and in any coordinate system.
The location of each source point is specified by X and Y coordinates
mapped over the same cube dimensions, aka “grid dimensions” : the grid may
have any dimensionality.  The X and Y coordinates must also have the same,
defined coord_system.
The weights, if specified, must have the same shape as the X and Y
coordinates.
The output grid can be any ‘normal’ XY grid, specified by <em>separate</em> X
and Y coordinates :  That is, X and Y have two different cube dimensions.
The output X and Y coordinates must also have a common, specified
coord_system.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.experimental.regrid.PointInCell">
<em class="property">class </em><code class="sig-prename descclassname">iris.experimental.regrid.</code><code class="sig-name descname">PointInCell</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.PointInCell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Point-in-cell regridding scheme suitable for regridding over one
or more orthogonal coordinates.</p>
<p>Optional Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>weights:</dt><dd><p>A <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.17)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> instance that defines the weights
for the grid cells of the source grid. Must have the same shape
as the data of the source grid.
If unspecified, equal weighting is assumed.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.experimental.regrid.PointInCell.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_grid</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.PointInCell.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a point-in-cell regridder to perform regridding from the
source grid to the target grid.</p>
<p>Typically you should use <a class="reference internal" href="../cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_grid:</dt><dd><p>The <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the source grid.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_grid</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the linear regridding scheme which uses the
scipy.interpolate.griddata to regrid unstructured data on to a grid.</p>
<p>The source cube and the target cube will be projected into a common
projection for the scipy calculation to be performed.</p>
<blockquote>
<div><dl class="class">
<dt id="iris.experimental.regrid.ProjectedUnstructuredLinear">
<em class="property">class </em><code class="sig-prename descclassname">iris.experimental.regrid.</code><code class="sig-name descname">ProjectedUnstructuredLinear</code><span class="sig-paren">(</span><em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.ProjectedUnstructuredLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Linear regridding scheme that uses scipy.interpolate.griddata on
projected unstructured data.</p>
<p>Optional Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>projection: <cite>cartopy.crs instance</cite></dt><dd><p>The projection that the scipy calculation is performed in.
If None is given, a PlateCarree projection is used. Defaults to
None.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.experimental.regrid.ProjectedUnstructuredLinear.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_cube</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.ProjectedUnstructuredLinear.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a linear regridder to perform regridding, using
scipy.interpolate.griddata from unstructured source points to the
target grid. The regridding calculation is performed in the given
projection.</p>
<p>Typically you should use <a class="reference internal" href="../cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_cube:</dt><dd><p>The <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the unstructured source
points.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_cube</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<p class="hr_p"><a href="#">&uarr;&#32&#32 top &#32&#32&uarr;</a></p>
<!--<hr class="docutils" />
--><p>This class describes the nearest regridding scheme which uses the
scipy.interpolate.griddata to regrid unstructured data on to a grid.</p>
<p>The source cube and the target cube will be projected into a common
projection for the scipy calculation to be performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="../analysis.html#iris.analysis.UnstructuredNearest" title="iris.analysis.UnstructuredNearest"><code class="xref py py-class docutils literal notranslate"><span class="pre">iris.analysis.UnstructuredNearest</span></code></a> scheme performs
essentially the same job.  That calculation is more rigorously
correct and may be applied to larger data regions (including global).
This one however, where applicable, is substantially faster.</p>
</div>
<blockquote>
<div><dl class="class">
<dt id="iris.experimental.regrid.ProjectedUnstructuredNearest">
<em class="property">class </em><code class="sig-prename descclassname">iris.experimental.regrid.</code><code class="sig-name descname">ProjectedUnstructuredNearest</code><span class="sig-paren">(</span><em class="sig-param">projection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.ProjectedUnstructuredNearest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Nearest regridding scheme that uses scipy.interpolate.griddata on
projected unstructured data.</p>
<p>Optional Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>projection: <cite>cartopy.crs instance</cite></dt><dd><p>The projection that the scipy calculation is performed in.
If None is given, a PlateCarree projection is used. Defaults to
None.</p>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="iris.experimental.regrid.ProjectedUnstructuredNearest.regridder">
<code class="sig-name descname">regridder</code><span class="sig-paren">(</span><em class="sig-param">src_cube</em>, <em class="sig-param">target_grid</em><span class="sig-paren">)</span><a class="headerlink" href="#iris.experimental.regrid.ProjectedUnstructuredNearest.regridder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a nearest-neighbour regridder to perform regridding, using
scipy.interpolate.griddata from unstructured source points to the
target grid. The regridding calculation is performed in the given
projection.</p>
<p>Typically you should use <a class="reference internal" href="../cube.html#iris.cube.Cube.regrid" title="iris.cube.Cube.regrid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iris.cube.Cube.regrid()</span></code></a> for
regridding a cube. There are, however, some situations when
constructing your own regridder is preferable. These are detailed in
the <a class="reference internal" href="../../../userguide/interpolation_and_regridding.html#caching-a-regridder"><span class="std std-ref">user guide</span></a>.</p>
<p>Args:</p>
<ul class="simple">
<li><dl class="simple">
<dt>src_cube:</dt><dd><p>The <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the unstructured source
points.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>target_grid:</dt><dd><p>The <a class="reference internal" href="../cube.html#iris.cube.Cube" title="iris.cube.Cube"><code class="xref py py-class docutils literal notranslate"><span class="pre">Cube</span></code></a> defining the target grid.</p>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Returns:</dt><dd><p>A callable with the interface:</p>
<blockquote>
<div><p><cite>callable(cube)</cite></p>
</div></blockquote>
<p>where <cite>cube</cite> is a cube with the same grid as <cite>src_cube</cite>
that is to be regridded to the <cite>target_grid</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="regrid_conservative.html" title="iris.experimental.regrid_conservative"
             >next</a> |</li>
        <li class="right" >
          <a href="raster.html" title="iris.experimental.raster"
             >previous</a> |</li>
        <li><a href="../../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../../../contents.html">contents</a>|&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../iris.html" >Iris reference documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../experimental.html" >iris.experimental</a> &#187;</li> 
      </ul>
    </div>

    <div class="footer">
    <p style="text-align: left; float: left; margin: 0px; padding: 0 0 0 5px;">Documentation licensed under the <a href="http://reference.data.gov.uk/id/open-government-licence" rel="license">Open Government Licence</a></p>
        &copy; <a href="../../../copyright.html">British Crown Copyright</a> 2010 - 2020, Met Office
    </div>

    <!-- Include a version switcher to easily move between the documentation of different versions -->
    <script type=text/javascript src="/iris/docs/version_switch.js" async></script>

  </body>
</html>