
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>cf_units &#8212; cf_units 2.0.1.dev1+markdown_readme documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for cf_units</h1><div class="highlight"><pre>
<span></span><span class="c1"># (C) British Crown Copyright 2015 - 2018, Met Office</span>
<span class="c1">#</span>
<span class="c1"># This file is part of cf_units.</span>
<span class="c1">#</span>
<span class="c1"># cf_units is free software: you can redistribute it and/or modify it under</span>
<span class="c1"># the terms of the GNU Lesser General Public License as published by the</span>
<span class="c1"># Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># cf_units is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Lesser General Public License</span>
<span class="c1"># along with cf_units.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Units of measure.</span>

<span class="sd">Provision of a wrapper class to support Unidata/UCAR UDUNITS-2, and the</span>
<span class="sd">cftime calendar functionality.</span>

<span class="sd">See also: `UDUNITS-2</span>
<span class="sd">&lt;http://www.unidata.ucar.edu/software/udunits&gt;`_.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span><span class="p">)</span>  <span class="c1"># noqa</span>

<span class="kn">import</span> <span class="nn">six</span>

<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">cftime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="k">import</span> <span class="n">_OrderedHashable</span><span class="p">,</span> <span class="n">approx_equal</span>

<span class="kn">from</span> <span class="nn">cf_units</span> <span class="k">import</span> <span class="n">_udunits2</span> <span class="k">as</span> <span class="n">_ud</span>
<span class="kn">from</span> <span class="nn">cf_units._udunits2</span> <span class="k">import</span> <span class="p">(</span><span class="n">UT_ASCII</span><span class="p">,</span> <span class="n">UT_ISO_8859_1</span><span class="p">,</span> <span class="n">UT_LATIN1</span><span class="p">,</span> <span class="n">UT_UTF8</span><span class="p">,</span>
                                <span class="n">UT_NAMES</span><span class="p">,</span> <span class="n">UT_DEFINITION</span><span class="p">)</span>


<span class="c1"># Define __version__ based on versioneer&#39;s interpretation.</span>
<span class="kn">from</span> <span class="nn">._version</span> <span class="k">import</span> <span class="n">get_versions</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="n">get_versions</span><span class="p">()[</span><span class="s1">&#39;version&#39;</span><span class="p">]</span>
<span class="k">del</span> <span class="n">get_versions</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;CALENDAR_STANDARD&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_GREGORIAN&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_PROLEPTIC_GREGORIAN&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_NO_LEAP&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_JULIAN&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_ALL_LEAP&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_365_DAY&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_366_DAY&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_360_DAY&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDARS&#39;</span><span class="p">,</span>
           <span class="s1">&#39;CALENDAR_ALIASES&#39;</span><span class="p">,</span>
           <span class="s1">&#39;UT_NAMES&#39;</span><span class="p">,</span>
           <span class="s1">&#39;UT_DEFINITION&#39;</span><span class="p">,</span>
           <span class="s1">&#39;UT_ASCII&#39;</span><span class="p">,</span>
           <span class="s1">&#39;FLOAT32&#39;</span><span class="p">,</span>
           <span class="s1">&#39;FLOAT64&#39;</span><span class="p">,</span>
           <span class="s1">&#39;julian_day2date&#39;</span><span class="p">,</span>
           <span class="s1">&#39;date2julian_day&#39;</span><span class="p">,</span>
           <span class="s1">&#39;is_time&#39;</span><span class="p">,</span>
           <span class="s1">&#39;is_vertical&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Unit&#39;</span><span class="p">,</span>
           <span class="s1">&#39;date2num&#39;</span><span class="p">,</span>
           <span class="s1">&#39;decode_time&#39;</span><span class="p">,</span>
           <span class="s1">&#39;encode_clock&#39;</span><span class="p">,</span>
           <span class="s1">&#39;encode_date&#39;</span><span class="p">,</span>
           <span class="s1">&#39;encode_time&#39;</span><span class="p">,</span>
           <span class="s1">&#39;num2date&#39;</span><span class="p">,</span>
           <span class="s1">&#39;suppress_errors&#39;</span><span class="p">]</span>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># module level constants</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="c1">#</span>
<span class="c1"># default constants</span>
<span class="c1">#</span>
<span class="n">EPOCH</span> <span class="o">=</span> <span class="s1">&#39;1970-01-01 00:00:00&#39;</span>
<span class="n">_UNKNOWN_UNIT_STRING</span> <span class="o">=</span> <span class="s1">&#39;unknown&#39;</span>
<span class="n">_UNKNOWN_UNIT_SYMBOL</span> <span class="o">=</span> <span class="s1">&#39;?&#39;</span>
<span class="n">_UNKNOWN_UNIT</span> <span class="o">=</span> <span class="p">[</span><span class="n">_UNKNOWN_UNIT_STRING</span><span class="p">,</span> <span class="n">_UNKNOWN_UNIT_SYMBOL</span><span class="p">,</span> <span class="s1">&#39;???&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
<span class="n">_NO_UNIT_STRING</span> <span class="o">=</span> <span class="s1">&#39;no_unit&#39;</span>
<span class="n">_NO_UNIT_SYMBOL</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
<span class="n">_NO_UNIT</span> <span class="o">=</span> <span class="p">[</span><span class="n">_NO_UNIT_STRING</span><span class="p">,</span> <span class="n">_NO_UNIT_SYMBOL</span><span class="p">,</span> <span class="s1">&#39;no unit&#39;</span><span class="p">,</span> <span class="s1">&#39;no-unit&#39;</span><span class="p">,</span> <span class="s1">&#39;nounit&#39;</span><span class="p">]</span>
<span class="n">_UNIT_DIMENSIONLESS</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
<span class="n">_OP_SINCE</span> <span class="o">=</span> <span class="s1">&#39; since &#39;</span>
<span class="n">_CATEGORY_UNKNOWN</span><span class="p">,</span> <span class="n">_CATEGORY_NO_UNIT</span><span class="p">,</span> <span class="n">_CATEGORY_UDUNIT</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># libudunits2 constants</span>
<span class="c1">#</span>
<span class="n">UT_FORMATS</span> <span class="o">=</span> <span class="p">[</span><span class="n">UT_ASCII</span><span class="p">,</span> <span class="n">UT_ISO_8859_1</span><span class="p">,</span> <span class="n">UT_LATIN1</span><span class="p">,</span> <span class="n">UT_UTF8</span><span class="p">,</span> <span class="n">UT_NAMES</span><span class="p">,</span>
              <span class="n">UT_DEFINITION</span><span class="p">]</span>

<span class="c1">#</span>
<span class="c1"># cftime constants</span>
<span class="c1">#</span>
<span class="n">CALENDAR_STANDARD</span> <span class="o">=</span> <span class="s1">&#39;standard&#39;</span>
<span class="n">CALENDAR_GREGORIAN</span> <span class="o">=</span> <span class="s1">&#39;gregorian&#39;</span>
<span class="n">CALENDAR_PROLEPTIC_GREGORIAN</span> <span class="o">=</span> <span class="s1">&#39;proleptic_gregorian&#39;</span>
<span class="n">CALENDAR_NO_LEAP</span> <span class="o">=</span> <span class="s1">&#39;noleap&#39;</span>
<span class="n">CALENDAR_JULIAN</span> <span class="o">=</span> <span class="s1">&#39;julian&#39;</span>
<span class="n">CALENDAR_ALL_LEAP</span> <span class="o">=</span> <span class="s1">&#39;all_leap&#39;</span>
<span class="n">CALENDAR_365_DAY</span> <span class="o">=</span> <span class="s1">&#39;365_day&#39;</span>
<span class="n">CALENDAR_366_DAY</span> <span class="o">=</span> <span class="s1">&#39;366_day&#39;</span>
<span class="n">CALENDAR_360_DAY</span> <span class="o">=</span> <span class="s1">&#39;360_day&#39;</span>

<span class="c1">#: The calendars recognised by cf_units.</span>
<span class="c1">#: These are accessible as strings, or as constants in the form</span>
<span class="c1">#: ``cf_units.CALENDAR_{ calendar_name.upper() }``. For example,</span>
<span class="c1">#: ``cf_units.CALENDAR_NO_LEAP`` and ``cf_units.CALENDAR_366_DAY``.</span>
<span class="n">CALENDARS</span> <span class="o">=</span> <span class="p">[</span><span class="n">CALENDAR_STANDARD</span><span class="p">,</span> <span class="n">CALENDAR_GREGORIAN</span><span class="p">,</span>
             <span class="n">CALENDAR_PROLEPTIC_GREGORIAN</span><span class="p">,</span> <span class="n">CALENDAR_NO_LEAP</span><span class="p">,</span> <span class="n">CALENDAR_JULIAN</span><span class="p">,</span>
             <span class="n">CALENDAR_ALL_LEAP</span><span class="p">,</span> <span class="n">CALENDAR_365_DAY</span><span class="p">,</span> <span class="n">CALENDAR_366_DAY</span><span class="p">,</span>
             <span class="n">CALENDAR_360_DAY</span><span class="p">]</span>

<span class="c1">#: Where calendars have multiple names, we map the alias to the</span>
<span class="c1">#: definitive form.</span>
<span class="n">CALENDAR_ALIASES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">CALENDAR_STANDARD</span><span class="p">:</span> <span class="n">CALENDAR_GREGORIAN</span><span class="p">,</span>
    <span class="n">CALENDAR_NO_LEAP</span><span class="p">:</span> <span class="n">CALENDAR_365_DAY</span><span class="p">,</span>
    <span class="n">CALENDAR_ALL_LEAP</span><span class="p">:</span> <span class="n">CALENDAR_366_DAY</span><span class="p">}</span>


<span class="c1">#</span>
<span class="c1"># floating point types</span>
<span class="c1">#</span>
<span class="n">FLOAT32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
<span class="n">FLOAT64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># module level statements</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="c1"># Convenience dictionary for the Unit convert method.</span>
<span class="n">_cv_convert_scalar</span> <span class="o">=</span> <span class="p">{</span><span class="n">FLOAT32</span><span class="p">:</span> <span class="n">_ud</span><span class="o">.</span><span class="n">convert_float</span><span class="p">,</span>
                      <span class="n">FLOAT64</span><span class="p">:</span> <span class="n">_ud</span><span class="o">.</span><span class="n">convert_double</span><span class="p">}</span>
<span class="n">_cv_convert_array</span> <span class="o">=</span> <span class="p">{</span><span class="n">FLOAT32</span><span class="p">:</span> <span class="n">_ud</span><span class="o">.</span><span class="n">convert_floats</span><span class="p">,</span>
                     <span class="n">FLOAT64</span><span class="p">:</span> <span class="n">_ud</span><span class="o">.</span><span class="n">convert_doubles</span><span class="p">}</span>

<span class="c1"># Map of ut_encodings to encoding strings</span>
<span class="n">_encoding_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">UT_ASCII</span><span class="p">:</span> <span class="s1">&#39;ascii&#39;</span><span class="p">,</span>
                    <span class="n">UT_ISO_8859_1</span><span class="p">:</span> <span class="s1">&#39;iso_8859_1&#39;</span><span class="p">,</span>
                    <span class="n">UT_LATIN1</span><span class="p">:</span> <span class="s1">&#39;latin1&#39;</span><span class="p">,</span>
                    <span class="n">UT_UTF8</span><span class="p">:</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">}</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">suppress_errors</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Suppresses all error messages from UDUNITS-2.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_default_handler</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">set_error_message_handler</span><span class="p">(</span><span class="n">_ud</span><span class="o">.</span><span class="n">ignore</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">_ud</span><span class="o">.</span><span class="n">set_error_message_handler</span><span class="p">(</span><span class="n">_default_handler</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1"># load the UDUNITS-2 xml-formatted unit-database</span>
<span class="c1">#:</span>
<span class="c1"># Ignore standard noisy UDUNITS-2 start-up.</span>
<span class="k">with</span> <span class="n">suppress_errors</span><span class="p">():</span>
    <span class="c1"># Load the unit-database from the default location (modified via</span>
    <span class="c1"># the UDUNITS2_XML_PATH environment variable) and if that fails look</span>
    <span class="c1"># relative to sys.prefix to support environments such as conda.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_ud_system</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">read_xml</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span><span class="p">:</span>
        <span class="n">_alt_xml_path</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_option</span><span class="p">(</span>
            <span class="s1">&#39;System&#39;</span><span class="p">,</span> <span class="s1">&#39;udunits2_xml_path&#39;</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span> <span class="s1">&#39;share&#39;</span><span class="p">,</span> <span class="s1">&#39;udunits&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;udunits2.xml&#39;</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_ud_system</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">read_xml</span><span class="p">(</span><span class="n">_alt_xml_path</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="s1">&#39;: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">e</span><span class="o">.</span><span class="n">error_msg</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">errnum</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span>
                <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">] Failed to open UDUNITS-2 XML unit database</span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">status_msg</span><span class="p">(),</span> <span class="n">error_msg</span><span class="p">))</span>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># module level function definitions</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<div class="viewcode-block" id="encode_time"><a class="viewcode-back" href="../utilities.html#cf_units.encode_time">[docs]</a><span class="k">def</span> <span class="nf">encode_time</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return date/clock time encoded as a double precision value.</span>

<span class="sd">    Encoding performed using UDUNITS-2 hybrid Gregorian/Julian calendar.</span>
<span class="sd">    Dates on or after 1582-10-15 are assumed to be Gregorian dates;</span>
<span class="sd">    dates before that are assumed to be Julian dates. In particular, the</span>
<span class="sd">    year 1 BCE is immediately followed by the year 1 CE.</span>

<span class="sd">    Args:</span>

<span class="sd">    * year (int):</span>
<span class="sd">        Year value to be encoded.</span>
<span class="sd">    * month (int):</span>
<span class="sd">        Month value to be encoded.</span>
<span class="sd">    * day (int):</span>
<span class="sd">        Day value to be encoded.</span>
<span class="sd">    * hour (int):</span>
<span class="sd">        Hour value to be encoded.</span>
<span class="sd">    * minute (int):</span>
<span class="sd">        Minute value to be encoded.</span>
<span class="sd">    * second (int):</span>
<span class="sd">        Second value to be encoded.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; cf_units.encode_time(1970, 1, 1, 0, 0, 0)</span>
<span class="sd">        -978307200.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
</div>
    <span class="k">return</span> <span class="n">_ud</span><span class="o">.</span><span class="n">encode_time</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">,</span> <span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>


<div class="viewcode-block" id="encode_date"><a class="viewcode-back" href="../utilities.html#cf_units.encode_date">[docs]</a><span class="k">def</span> <span class="nf">encode_date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return date encoded as a double precision value.</span>

<span class="sd">    Encoding performed using UDUNITS-2 hybrid Gergorian/Julian calendar.</span>
<span class="sd">    Dates on or after 1582-10-15 are assumed to be Gregorian dates;</span>
<span class="sd">    dates before that are assumed to be Julian dates. In particular, the</span>
<span class="sd">    year 1 BCE is immediately followed by the year 1 CE.</span>

<span class="sd">    Args:</span>

<span class="sd">    * year (int):</span>
<span class="sd">        Year value to be encoded.</span>
<span class="sd">    * month (int):</span>
<span class="sd">        Month value to be encoded.</span>
<span class="sd">    * day (int):</span>
<span class="sd">        Day value to be encoded.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; cf_units.encode_date(1970, 1, 1)</span>
<span class="sd">        -978307200.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
</div>
    <span class="k">return</span> <span class="n">_ud</span><span class="o">.</span><span class="n">encode_date</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span>


<div class="viewcode-block" id="encode_clock"><a class="viewcode-back" href="../utilities.html#cf_units.encode_clock">[docs]</a><span class="k">def</span> <span class="nf">encode_clock</span><span class="p">(</span><span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return clock time encoded as a double precision value.</span>

<span class="sd">    Args:</span>

<span class="sd">    * hour (int):</span>
<span class="sd">        Hour value to be encoded.</span>
<span class="sd">    * minute (int):</span>
<span class="sd">        Minute value to be encoded.</span>
<span class="sd">    * second (int):</span>
<span class="sd">        Second value to be encoded.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; cf_units.encode_clock(0, 0, 0)</span>
<span class="sd">        0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
</div>
    <span class="k">return</span> <span class="n">_ud</span><span class="o">.</span><span class="n">encode_clock</span><span class="p">(</span><span class="n">hour</span><span class="p">,</span> <span class="n">minute</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>


<div class="viewcode-block" id="decode_time"><a class="viewcode-back" href="../utilities.html#cf_units.decode_time">[docs]</a><span class="k">def</span> <span class="nf">decode_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode a double precision date/clock time value into its component</span>
<span class="sd">    parts and return as tuple.</span>

<span class="sd">    Decode time into it&#39;s year, month, day, hour, minute, second, and</span>
<span class="sd">    resolution component parts. Where resolution is the uncertainty of</span>
<span class="sd">    the time in seconds.</span>

<span class="sd">    Args:</span>

<span class="sd">    * time (float): Date/clock time encoded as a double precision value.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple of (year, month, day, hour, minute, second, resolution).</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; cf_units.decode_time(cf_units.encode_time(1970, 1, 1, 0, 0, 0))</span>
<span class="sd">        (1970, 1, 1, 0, 0, 0.0, 1.086139178596568e-07)</span>

<span class="sd">    &quot;&quot;&quot;</span></div>
    <span class="k">return</span> <span class="n">_ud</span><span class="o">.</span><span class="n">decode_time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>


<div class="viewcode-block" id="julian_day2date"><a class="viewcode-back" href="../utilities.html#cf_units.julian_day2date">[docs]</a><span class="k">def</span> <span class="nf">julian_day2date</span><span class="p">(</span><span class="n">julian_day</span><span class="p">,</span> <span class="n">calendar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a cftime datetime-like object representing the Julian day.</span>

<span class="sd">    If calendar is &#39;standard&#39; or &#39;gregorian&#39;, Julian day follows</span>
<span class="sd">    Julian calendar on and before 1582-10-5, Gregorian calendar after</span>
<span class="sd">    1582-10-15.</span>
<span class="sd">    If calendar is &#39;proleptic_gregorian&#39;, Julian Day follows Gregorian</span>
<span class="sd">    calendar.</span>
<span class="sd">    If calendar is &#39;julian&#39;, Julian Day follows Julian calendar.</span>

<span class="sd">    The datetime object is a &#39;real&#39; datetime object if the date falls in</span>
<span class="sd">    the Gregorian calendar (i.e. calendar is &#39;proleptic_gregorian&#39;, or</span>
<span class="sd">    calendar is &#39;standard&#39;/&#39;gregorian&#39; and the date is after 1582-10-15).</span>
<span class="sd">    Otherwise, it&#39;s a &#39;phony&#39; datetime object which is actually an instance</span>
<span class="sd">    of cftime.datetime.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">        Meeus, Jean (1998) Astronomical Algorithms (2nd Edition).</span>
<span class="sd">        Willmann-Bell, Virginia. p. 63.</span>

<span class="sd">    Args:</span>

<span class="sd">    * julian_day (float):</span>
<span class="sd">        Julian day with a resolution of 1 second.</span>
<span class="sd">    * calendar (string):</span>
<span class="sd">        Name of the calendar, see cf_units.CALENDARS.</span>

<span class="sd">    Returns:</span>
<span class="sd">        datetime or cftime.datetime.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; import datetime</span>
<span class="sd">        &gt;&gt;&gt; cf_units.julian_day2date(</span>
<span class="sd">        ...    cf_units.date2julian_day(datetime.datetime(1970, 1, 1, 0, 0, 0),</span>
<span class="sd">        ...                             cf_units.CALENDAR_STANDARD),</span>
<span class="sd">        ...     cf_units.CALENDAR_STANDARD)</span>
<span class="sd">        datetime.datetime(1970, 1, 1, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
</div>
    <span class="k">return</span> <span class="n">cftime</span><span class="o">.</span><span class="n">DateFromJulianDay</span><span class="p">(</span><span class="n">julian_day</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span>


<div class="viewcode-block" id="date2julian_day"><a class="viewcode-back" href="../utilities.html#cf_units.date2julian_day">[docs]</a><span class="k">def</span> <span class="nf">date2julian_day</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">calendar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Julian day (resolution of 1 second) from a cftime</span>
<span class="sd">    datetime-like object.</span>

<span class="sd">    If calendar is &#39;standard&#39; or &#39;gregorian&#39;, Julian day follows Julian</span>
<span class="sd">    calendar on and before 1582-10-5, Gregorian calendar after 1582-10-15.</span>
<span class="sd">    If calendar is &#39;proleptic_gregorian&#39;, Julian day follows Gregorian</span>
<span class="sd">    calendar.</span>
<span class="sd">    If calendar is &#39;julian&#39;, Julian day follows Julian calendar.</span>

<span class="sd">    Algorithm:</span>
<span class="sd">        Meeus, Jean (1998) Astronomical Algorithms (2nd Edition).</span>
<span class="sd">        Willmann-Bell, Virginia. p. 63.</span>

<span class="sd">    Args:</span>

<span class="sd">    * date (cftime.date):</span>
<span class="sd">        Date and time representation.</span>
<span class="sd">    * calendar (string):</span>
<span class="sd">        Name of the calendar, see cf_units.CALENDARS.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; import datetime</span>
<span class="sd">        &gt;&gt;&gt; cf_units.date2julian_day(datetime.datetime(1970, 1, 1, 0, 0, 0),</span>
<span class="sd">        ...                          cf_units.CALENDAR_STANDARD)</span>
<span class="sd">        2440587.5...</span>

<span class="sd">    &quot;&quot;&quot;</span>
</div>
    <span class="k">return</span> <span class="n">cftime</span><span class="o">.</span><span class="n">JulianDayFromDate</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span>


<div class="viewcode-block" id="date2num"><a class="viewcode-back" href="../utilities.html#cf_units.date2num">[docs]</a><span class="k">def</span> <span class="nf">date2num</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return numeric time value (resolution of 1 second) encoding of</span>
<span class="sd">    datetime object.</span>

<span class="sd">    The units of the numeric time values are described by the unit and</span>
<span class="sd">    calendar arguments. The datetime objects must be in UTC with no</span>
<span class="sd">    time-zone offset. If there is a time-zone offset in unit, it will be</span>
<span class="sd">    applied to the returned numeric values.</span>

<span class="sd">    Like the :func:`matplotlib.dates.date2num` function, except that it allows</span>
<span class="sd">    for different units and calendars.  Behaves the same as if</span>
<span class="sd">    unit = &#39;days since 0001-01-01 00:00:00&#39; and</span>
<span class="sd">    calendar = &#39;proleptic_gregorian&#39;.</span>

<span class="sd">    Args:</span>

<span class="sd">    * date (datetime):</span>
<span class="sd">        A datetime object or a sequence of datetime objects.</span>
<span class="sd">        The datetime objects should not include a time-zone offset.</span>
<span class="sd">    * unit (string):</span>
<span class="sd">        A string of the form &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39; describing</span>
<span class="sd">        the time units. The &lt;time-unit&gt; can be days, hours, minutes or seconds.</span>
<span class="sd">        The &lt;time-origin&gt; is a date/time reference point. A valid choice</span>
<span class="sd">        would be unit=&#39;hours since 1800-01-01 00:00:00 -6:00&#39;.</span>
<span class="sd">    * calendar (string):</span>
<span class="sd">        Name of the calendar, see cf_units.CALENDARS.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float, or numpy.ndarray of float.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; import datetime</span>
<span class="sd">        &gt;&gt;&gt; dt1 = datetime.datetime(1970, 1, 1, 6, 0, 0)</span>
<span class="sd">        &gt;&gt;&gt; dt2 = datetime.datetime(1970, 1, 1, 7, 0, 0)</span>
<span class="sd">        &gt;&gt;&gt; cf_units.date2num(dt1, &#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">        ...               cf_units.CALENDAR_STANDARD)</span>
<span class="sd">        6.0</span>
<span class="sd">        &gt;&gt;&gt; cf_units.date2num([dt1, dt2], &#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">        ...               cf_units.CALENDAR_STANDARD)</span>
<span class="sd">        array([6., 7.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># ensure to strip out any &#39;UTC&#39; postfix which is generated by</span>
    <span class="c1"># UDUNITS-2 formatted output and causes the cftime parser</span>
    <span class="c1"># to choke</span>
    <span class="c1">#</span>
    <span class="n">unit_string</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot; UTC&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unit_string</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot; since epoch&quot;</span><span class="p">):</span>
        <span class="n">unit_string</span> <span class="o">=</span> <span class="n">unit_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="n">EPOCH</span><span class="p">)</span>
    <span class="n">unit_inst</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit_string</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="n">calendar</span><span class="p">)</span></div>
    <span class="k">return</span> <span class="n">unit_inst</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_discard_microsecond</span><span class="p">(</span><span class="n">date</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a date with the microsecond componenet discarded.</span>

<span class="sd">    Works for scalars, sequences and numpy arrays. Returns a scalar</span>
<span class="sd">    if input is a scalar, else returns a numpy array.</span>

<span class="sd">    Args:</span>

<span class="sd">    * date (datetime.datetime or cftime.datetime):</span>
<span class="sd">        Date value/s</span>

<span class="sd">    Returns:</span>
<span class="sd">        datetime, or numpy.ndarray of datetime object.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">dates</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">dates</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="c1"># Create date objects of the same type returned by utime.num2date()</span>
    <span class="c1"># (either datetime.datetime or cftime.datetime), discarding the</span>
    <span class="c1"># microseconds</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">month</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="p">,</span>
                                        <span class="n">d</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">second</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="p">()</span> <span class="k">else</span> <span class="n">dates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="num2date"><a class="viewcode-back" href="../utilities.html#cf_units.num2date">[docs]</a><span class="k">def</span> <span class="nf">num2date</span><span class="p">(</span><span class="n">time_value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return datetime encoding of numeric time value (resolution of 1 second).</span>

<span class="sd">    The units of the numeric time value are described by the unit and</span>
<span class="sd">    calendar arguments. The returned datetime object represent UTC with</span>
<span class="sd">    no time-zone offset, even if the specified unit contain a time-zone</span>
<span class="sd">    offset.</span>

<span class="sd">    Like the :func:`matplotlib.dates.num2date` function, except that it allows</span>
<span class="sd">    for different units and calendars.  Behaves the same if</span>
<span class="sd">    unit = &#39;days since 001-01-01 00:00:00&#39;}</span>
<span class="sd">    calendar = &#39;proleptic_gregorian&#39;.</span>

<span class="sd">    The datetime instances returned are &#39;real&#39; python datetime</span>
<span class="sd">    objects if the date falls in the Gregorian calendar (i.e.</span>
<span class="sd">    calendar=&#39;proleptic_gregorian&#39;, or calendar = &#39;standard&#39; or &#39;gregorian&#39;</span>
<span class="sd">    and the date is after 1582-10-15). Otherwise, they are &#39;phony&#39; datetime</span>
<span class="sd">    objects which support some but not all the methods of &#39;real&#39; python</span>
<span class="sd">    datetime objects.  This is because the python datetime module cannot</span>
<span class="sd">    use the &#39;proleptic_gregorian&#39; calendar, even before the switch</span>
<span class="sd">    occured from the Julian calendar in 1582. The datetime instances</span>
<span class="sd">    do not contain a time-zone offset, even if the specified unit</span>
<span class="sd">    contains one.</span>

<span class="sd">    Works for scalars, sequences and numpy arrays. Returns a scalar</span>
<span class="sd">    if input is a scalar, else returns a numpy array.</span>

<span class="sd">    Args:</span>

<span class="sd">    * time_value (float):</span>
<span class="sd">        Numeric time value/s. Maximum resolution is 1 second.</span>
<span class="sd">    * unit (sting):</span>
<span class="sd">        A string of the form &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39;</span>
<span class="sd">        describing the time units. The &lt;time-unit&gt; can be days, hours,</span>
<span class="sd">        minutes or seconds. The &lt;time-origin&gt; is the date/time reference</span>
<span class="sd">        point. A valid choice would be</span>
<span class="sd">        unit=&#39;hours since 1800-01-01 00:00:00 -6:00&#39;.</span>
<span class="sd">    * calendar (string):</span>
<span class="sd">        Name of the calendar, see cf_units.CALENDARS.</span>

<span class="sd">    Returns:</span>
<span class="sd">        datetime, or numpy.ndarray of datetime object.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; import datetime</span>
<span class="sd">        &gt;&gt;&gt; cf_units.num2date(6, &#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">        ...                   cf_units.CALENDAR_STANDARD)</span>
<span class="sd">        datetime.datetime(1970, 1, 1, 6, 0)</span>
<span class="sd">        &gt;&gt;&gt; cf_units.num2date([6, 7], &#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">        ...                   cf_units.CALENDAR_STANDARD)</span>
<span class="sd">        array([datetime.datetime(1970, 1, 1, 6, 0),</span>
<span class="sd">               datetime.datetime(1970, 1, 1, 7, 0)], dtype=object)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># ensure to strip out any &#39;UTC&#39; postfix which is generated by</span>
    <span class="c1"># UDUNITS-2 formatted output and causes the cftime parser</span>
    <span class="c1"># to choke</span>
    <span class="c1">#</span>
    <span class="n">unit_string</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot; UTC&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unit_string</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot; since epoch&quot;</span><span class="p">):</span>
        <span class="n">unit_string</span> <span class="o">=</span> <span class="n">unit_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="n">EPOCH</span><span class="p">)</span>
    <span class="n">unit_inst</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit_string</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="n">calendar</span><span class="p">)</span></div>
    <span class="k">return</span> <span class="n">unit_inst</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">time_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_num2date_to_nearest_second</span><span class="p">(</span><span class="n">time_value</span><span class="p">,</span> <span class="n">utime</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return datetime encoding of numeric time value with respect to the given</span>
<span class="sd">    time reference units, with a resolution of 1 second.</span>

<span class="sd">    * time_value (float):</span>
<span class="sd">        Numeric time value/s.</span>
<span class="sd">    * utime (cftime.utime):</span>
<span class="sd">        netcdf.utime object with which to perform the conversion/s.</span>

<span class="sd">    Returns:</span>
<span class="sd">        datetime, or numpy.ndarray of datetime object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">time_value</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">time_values</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">time_values</span> <span class="o">=</span> <span class="n">time_values</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="c1"># We account for the edge case where the time is in seconds and has a</span>
    <span class="c1"># half second: utime.num2date() may produce a date that would round</span>
    <span class="c1"># down.</span>
    <span class="c1">#</span>
    <span class="c1"># Note that this behaviour is different to the num2date function in version</span>
    <span class="c1"># 1.1 and earlier of cftime that didn&#39;t have microsecond precision. In</span>
    <span class="c1"># those versions, a half-second value would be rounded up or down</span>
    <span class="c1"># arbitrarily. It is probably not possible to replicate that behaviour with</span>
    <span class="c1"># later versions, if one wished to do so for the sake of consistency.</span>
    <span class="n">has_half_seconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">utime</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;seconds&#39;</span><span class="p">,</span>
                                      <span class="n">time_values</span> <span class="o">%</span> <span class="mf">1.</span> <span class="o">==</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">utime</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">time_values</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># We can assume all or none of the dates have a microsecond attribute</span>
        <span class="n">microseconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">microsecond</span> <span class="k">if</span> <span class="n">d</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dates</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">microseconds</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">round_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">has_half_seconds</span><span class="p">,</span> <span class="n">microseconds</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ceil_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">has_half_seconds</span><span class="p">,</span> <span class="n">microseconds</span> <span class="o">&gt;=</span> <span class="mi">500000</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">time_values</span><span class="p">[</span><span class="n">ceil_mask</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">useconds</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;second&#39;</span><span class="p">)</span>
        <span class="n">second_frac</span> <span class="o">=</span> <span class="n">useconds</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">utime</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
        <span class="n">dates</span><span class="p">[</span><span class="n">ceil_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">utime</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">time_values</span><span class="p">[</span><span class="n">ceil_mask</span><span class="p">]</span> <span class="o">+</span> <span class="n">second_frac</span><span class="p">)</span>
    <span class="n">dates</span><span class="p">[</span><span class="n">round_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">_discard_microsecond</span><span class="p">(</span><span class="n">dates</span><span class="p">[</span><span class="n">round_mask</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">dates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="p">()</span> <span class="k">else</span> <span class="n">dates</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1">########################################################################</span>
<span class="c1">#</span>
<span class="c1"># unit wrapper class for unidata/ucar UDUNITS-2</span>
<span class="c1">#</span>
<span class="c1">########################################################################</span>

<span class="k">def</span> <span class="nf">_Unit</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">_OrderedHashable</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span>
    <span class="n">unit</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unit</span>


<span class="n">_CACHE</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a Unit corresponding to the given unit.</span>

<span class="sd">    .. note::</span>

<span class="sd">        If the given unit is already a Unit it will be returned unchanged.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">Unit</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">unit</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">use_cache</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">use_cache</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_CACHE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Typically unit is a string, however we cater for other types of</span>
            <span class="c1"># &#39;unit&#39; (e.g. iris.unit.Unit).</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Unit</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="s1">&#39;calendar&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">use_cache</span><span class="p">:</span>
                <span class="n">_CACHE</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">is_time</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether the unit is a related SI Unit of time.</span>

<span class="sd">    Args:</span>

<span class="sd">    * unit (string/Unit): Unit to be compared.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; cf_units.is_time(&#39;hours&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; cf_units.is_time(&#39;meters&#39;)</span>
<span class="sd">        False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">is_time</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">is_vertical</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether the unit is a related SI Unit of pressure or distance.</span>

<span class="sd">    Args:</span>

<span class="sd">    * unit (string/Unit): Unit to be compared.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Boolean.</span>

<span class="sd">    For example:</span>

<span class="sd">        &gt;&gt;&gt; import cf_units</span>
<span class="sd">        &gt;&gt;&gt; cf_units.is_vertical(&#39;millibar&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; cf_units.is_vertical(&#39;km&#39;)</span>
<span class="sd">        True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">as_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">is_vertical</span><span class="p">()</span>


<div class="viewcode-block" id="Unit"><a class="viewcode-back" href="../unit.html#cf_units.Unit">[docs]</a><span class="k">class</span> <span class="nc">Unit</span><span class="p">(</span><span class="n">_OrderedHashable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to represent S.I. units and support common operations to</span>
<span class="sd">    manipulate such units in a consistent manner as per UDUNITS-2.</span>

<span class="sd">    These operations include scaling the unit, offsetting the unit by a</span>
<span class="sd">    constant or time, inverting the unit, raising the unit by a power,</span>
<span class="sd">    taking a root of the unit, taking a log of the unit, multiplying the</span>
<span class="sd">    unit by a constant or another unit, dividing the unit by a constant</span>
<span class="sd">    or another unit, comparing units, copying units and converting unit</span>
<span class="sd">    data to single precision or double precision floating point numbers.</span>

<span class="sd">    This class also supports time and calendar defintion and manipulation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_init_from_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_as_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">)</span>

    <span class="c1"># Provide hash semantics</span>

    <span class="k">def</span> <span class="nf">_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_tuple</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_identity</span><span class="p">())</span>

    <span class="c1"># Provide default ordering semantics</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_identity</span><span class="p">()</span>

    <span class="c1"># Prevent attribute updates</span>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Instances of </span><span class="si">%s</span><span class="s1"> are immutable&#39;</span> <span class="o">%</span>
                             <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Instances of </span><span class="si">%s</span><span class="s1"> are immutable&#39;</span> <span class="o">%</span>
                             <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="c1"># Declare the attribute names relevant to the ordered and hashable</span>
    <span class="c1">#  behaviour.</span>
    <span class="n">_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">,</span> <span class="s1">&#39;ut_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;calendar&#39;</span><span class="p">,</span> <span class="s1">&#39;origin&#39;</span><span class="p">)</span>

    <span class="n">category</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="s1">&#39;Is this an unknown unit, a no-unit, or a UDUNITS-2 unit.&#39;</span>

    <span class="n">ut_unit</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="s1">&#39;Reference to the quantity defining the UDUNITS-2 unit.&#39;</span>

    <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="s1">&#39;Represents the unit calendar name, see cf_units.CALENDARS&#39;</span>

    <span class="n">origin</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="s1">&#39;The original string used to create this unit.&#39;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">calendar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a wrapper instance for UDUNITS-2.</span>

<span class="sd">        An optional calendar may be provided for a unit which defines a</span>
<span class="sd">        time reference of the form &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39;</span>
<span class="sd">        i.e. unit=&#39;days since 1970-01-01 00:00:00&#39;. For a unit that is a</span>
<span class="sd">        time reference, the default calendar is &#39;standard&#39;.</span>

<span class="sd">        Accepted calendars are as follows,</span>

<span class="sd">        * &#39;standard&#39; or &#39;gregorian&#39; - Mixed Gregorian/Julian calendar as</span>
<span class="sd">          defined by udunits.</span>
<span class="sd">        * &#39;proleptic_gregorian&#39; - A Gregorian calendar extended to dates</span>
<span class="sd">          before 1582-10-15. A year is a leap year if either,</span>

<span class="sd">            1. It is divisible by 4 but not by 100, or</span>
<span class="sd">            2. It is divisible by 400.</span>

<span class="sd">        * &#39;noleap&#39; or &#39;365_day&#39; - A Gregorian calendar without leap</span>
<span class="sd">          years i.e. all years are 365 days long.</span>
<span class="sd">        * &#39;all_leap&#39; or &#39;366_day&#39; - A Gregorian calendar with every year</span>
<span class="sd">          being a leap year i.e. all years are 366 days long.</span>
<span class="sd">        * &#39;360_day&#39; - All years are 360 days divided into 30 day months.</span>
<span class="sd">        * &#39;julian&#39; - Proleptic Julian calendar, extended to dates after</span>
<span class="sd">          1582-10-5. A year is a leap year if it is divisible by 4.</span>

<span class="sd">        Args:</span>

<span class="sd">        * unit:</span>
<span class="sd">            Specify the unit as defined by UDUNITS-2.</span>
<span class="sd">        * calendar (string):</span>
<span class="sd">            Describes the calendar used in time calculations. The</span>
<span class="sd">            default is &#39;standard&#39; or &#39;gregorian&#39; for a time reference</span>
<span class="sd">            unit.</span>

<span class="sd">        Returns:</span>

<span class="sd">            Unit object.</span>

<span class="sd">        Units should be set to &quot;no_unit&quot; for values which are strings.</span>
<span class="sd">        Units can also be set to &quot;unknown&quot; (or None).</span>
<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; from cf_units import Unit</span>
<span class="sd">            &gt;&gt;&gt; volts = Unit(&#39;volts&#39;)</span>
<span class="sd">            &gt;&gt;&gt; no_unit = Unit(&#39;no_unit&#39;)</span>
<span class="sd">            &gt;&gt;&gt; unknown = Unit(&#39;unknown&#39;)</span>
<span class="sd">            &gt;&gt;&gt; unknown = Unit(None)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">NULL_UNIT</span>
        <span class="n">calendar_</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39; utc&#39;</span><span class="p">):</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="p">[:</span><span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39; utc&#39;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot; since epoch&quot;</span><span class="p">):</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span> <span class="n">EPOCH</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;#&quot;</span> <span class="ow">in</span> <span class="n">unit</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_UNKNOWN_UNIT</span><span class="p">:</span>
            <span class="c1"># TODO - removing the option of an unknown unit. Currently</span>
            <span class="c1"># the auto generated MOSIG rules are missing units on a</span>
            <span class="c1"># number of phenomena which would lead to errors.</span>
            <span class="c1"># Will be addressed by work on metadata translation.</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">_CATEGORY_UNKNOWN</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">_UNKNOWN_UNIT_STRING</span>
        <span class="k">elif</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">_NO_UNIT</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">_CATEGORY_NO_UNIT</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">_NO_UNIT_STRING</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">category</span> <span class="o">=</span> <span class="n">_CATEGORY_UDUNIT</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">_ud_system</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">),</span> <span class="n">UT_ASCII</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to parse unit &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">unit</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_OP_SINCE</span> <span class="ow">in</span> <span class="n">unit</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">calendar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">calendar_</span> <span class="o">=</span> <span class="n">CALENDAR_GREGORIAN</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">calendar</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                    <span class="n">calendar_</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">calendar_</span> <span class="ow">in</span> <span class="n">CALENDAR_ALIASES</span><span class="p">:</span>
                        <span class="n">calendar_</span> <span class="o">=</span> <span class="n">CALENDAR_ALIASES</span><span class="p">[</span><span class="n">calendar_</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">calendar_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">CALENDARS</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is an unsupported calendar.&#39;</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">calendar</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected string-like calendar argument, got </span><span class="si">{!r}</span><span class="s1">.&#39;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">calendar</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_tuple</span><span class="p">((</span><span class="n">category</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar_</span><span class="p">,</span> <span class="n">unit</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_propogate_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">ud_err</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the UDUNITS-2 ut_status, the implementation-defined string</span>
<span class="sd">        corresponding to UDUNITS-2 errno from the UdunitsError and raise</span>
<span class="sd">        generic exception.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="s1">&#39;: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">ud_err</span><span class="o">.</span><span class="n">error_msg</span><span class="p">()</span> <span class="k">if</span> <span class="n">ud_err</span><span class="o">.</span><span class="n">errnum</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">] </span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ud_err</span><span class="o">.</span><span class="n">status_msg</span><span class="p">(),</span> <span class="n">msg</span><span class="p">,</span> <span class="n">error_msg</span><span class="p">))</span>

    <span class="c1"># NOTE:</span>
    <span class="c1"># &quot;__getstate__&quot; and &quot;__setstate__&quot; functions are defined here to</span>
    <span class="c1"># provide a custom interface for Pickle</span>
    <span class="c1">#  : Pickle &quot;normal&quot; behaviour is just to save/reinstate the object</span>
    <span class="c1">#    dictionary</span>
    <span class="c1">#  : that won&#39;t work here, because the &quot;ut_unit&quot; attribute is an</span>
    <span class="c1">#    object handle</span>
    <span class="c1">#    - the corresponding udunits object only exists in the original</span>
    <span class="c1">#      invocation</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># state capture method for Pickle.dump()</span>
        <span class="c1">#  - return the instance data needed to reconstruct a Unit value</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;unit_text&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="s1">&#39;calendar&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># object reconstruction method for Pickle.load()</span>
        <span class="c1"># intercept the Pickle.load() operation and call own __init__ again</span>
        <span class="c1">#  - this is to ensure a valid ut_unit attribute (as these</span>
        <span class="c1">#    handles aren&#39;t persistent)</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;unit_text&#39;</span><span class="p">],</span> <span class="n">calendar</span><span class="o">=</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;calendar&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Unit.is_time"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_time">[docs]</a>    <span class="k">def</span> <span class="nf">is_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether this unit is a related SI Unit of time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;hours&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_time()</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; v = cf_units.Unit(&#39;meter&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v.is_time()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">day</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">get_unit_by_name</span><span class="p">(</span><span class="n">_ud_system</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;day&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">are_convertible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">day</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.is_vertical"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_vertical">[docs]</a>    <span class="k">def</span> <span class="nf">is_vertical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine whether the unit is a related SI Unit of pressure or</span>
<span class="sd">        distance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;millibar&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_vertical()</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; v = cf_units.Unit(&#39;km&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v.is_vertical()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">get_unit_by_name</span><span class="p">(</span><span class="n">_ud_system</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">are_convertible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">bar</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">meter</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">get_unit_by_name</span><span class="p">(</span><span class="n">_ud_system</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;meter&#39;</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">are_convertible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">meter</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.is_udunits"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_udunits">[docs]</a>    <span class="k">def</span> <span class="nf">is_udunits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the unit is a vaild unit of UDUNITS.&quot;&quot;&quot;</span></div>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_ud</span><span class="o">.</span><span class="n">NULL_UNIT</span>

<div class="viewcode-block" id="Unit.is_time_reference"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_time_reference">[docs]</a>    <span class="k">def</span> <span class="nf">is_time_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the unit is a time reference unit of the form</span>
<span class="sd">        &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39;</span>
<span class="sd">        i.e. unit=&#39;days since 1970-01-01 00:00:00&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;days since epoch&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_time_reference()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span></div>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

<div class="viewcode-block" id="Unit.is_long_time_interval"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_long_time_interval">[docs]</a>    <span class="k">def</span> <span class="nf">is_long_time_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines whether this unit describes a time unit with a long time</span>
<span class="sd">        interval (&quot;months&quot; or &quot;years&quot;). These long time intervals *are*</span>
<span class="sd">        supported by `UDUNITS2` but are not supported by `cftime`. This</span>
<span class="sd">        discrepancy means we cannot run self.num2date() on a time unit with</span>
<span class="sd">        a long time interval.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;days since epoch&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_long_time_interval()</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;years since epoch&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_long_time_interval()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">long_time_intervals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
                         <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">long_time_intervals</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.title"><a class="viewcode-back" href="../unit.html#cf_units.Unit.title">[docs]</a>    <span class="k">def</span> <span class="nf">title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the unit value as a title string.</span>

<span class="sd">        Args:</span>

<span class="sd">        * value (float): Unit value to be incorporated into title string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;hours since epoch&#39;,</span>
<span class="sd">            ...                   calendar=cf_units.CALENDAR_STANDARD)</span>
<span class="sd">            &gt;&gt;&gt; u.title(10)</span>
<span class="sd">            &#39;1970-01-01 10:00:00&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">():</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *(read-only)* Return the modulus value of the unit.</span>

<span class="sd">        Convenience method that returns the unit modulus value as follows,</span>
<span class="sd">            * &#39;radians&#39; - pi*2</span>
<span class="sd">            * &#39;degrees&#39; - 360.0</span>
<span class="sd">            * Otherwise None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;degrees&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.modulus</span>
<span class="sd">            360.0</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="s1">&#39;radians&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="o">==</span> <span class="s1">&#39;degrees&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mf">360.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.is_convertible"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_convertible">[docs]</a>    <span class="k">def</span> <span class="nf">is_convertible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether two units are convertible.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other (Unit): Unit to be compared.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v = cf_units.Unit(&#39;kilometers&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_convertible(v)</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">()</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">()</span> <span class="ow">or</span> \
           <span class="n">other</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calendar</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">calendar</span> <span class="ow">and</span>
                      <span class="n">_ud</span><span class="o">.</span><span class="n">are_convertible</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">))</span></div>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.is_dimensionless"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_dimensionless">[docs]</a>    <span class="k">def</span> <span class="nf">is_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the unit is dimensionless.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_dimensionless()</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_dimensionless()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">==</span> <span class="n">_CATEGORY_UDUNIT</span> <span class="ow">and</span></div>
                <span class="nb">bool</span><span class="p">(</span><span class="n">_ud</span><span class="o">.</span><span class="n">is_dimensionless</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">)))</span>

<div class="viewcode-block" id="Unit.is_unknown"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_unknown">[docs]</a>    <span class="k">def</span> <span class="nf">is_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the unit is defined to be an *unknown* unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;unknown&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_unknown()</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_unknown()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span></div>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">==</span> <span class="n">_CATEGORY_UNKNOWN</span>

<div class="viewcode-block" id="Unit.is_no_unit"><a class="viewcode-back" href="../unit.html#cf_units.Unit.is_no_unit">[docs]</a>    <span class="k">def</span> <span class="nf">is_no_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the unit is defined to be a *no_unit* unit.</span>

<span class="sd">        Typically, a quantity such as a string, will have no associated</span>
<span class="sd">        unit to describe it. Such a class of quantity may be defined</span>
<span class="sd">        using the *no_unit* unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;no unit&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_no_unit()</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.is_no_unit()</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span></div>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">==</span> <span class="n">_CATEGORY_NO_UNIT</span>

<div class="viewcode-block" id="Unit.format"><a class="viewcode-back" href="../unit.html#cf_units.Unit.format">[docs]</a>    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a formatted string representation of the binary unit.</span>

<span class="sd">        Args:</span>

<span class="sd">        * option (cf_units.UT_FORMATS):</span>
<span class="sd">            Set the option of the formatted string representation.</span>
<span class="sd">            Valid encoding options may be at most one of the following</span>
<span class="sd">            enumerations:</span>
<span class="sd">            * Unit.UT_ASCII</span>
<span class="sd">            * Unit.UT_ISO_8859_1</span>
<span class="sd">            * Unit.UT_LATIN1</span>
<span class="sd">            * Unit.UT_UTF8</span>

<span class="sd">            Any combination of the following may also be used:</span>
<span class="sd">            * Unit.UT_NAMES</span>
<span class="sd">            * Unit.UT_DEFINITION</span>

<span class="sd">            Multiple options may be combined within a list. The default</span>
<span class="sd">            option is cf_units.UT_ASCII.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.format()</span>
<span class="sd">            &#39;m&#39;</span>
<span class="sd">            &gt;&gt;&gt; u.format(cf_units.UT_NAMES)</span>
<span class="sd">            &#39;meter&#39;</span>
<span class="sd">            &gt;&gt;&gt; u.format(cf_units.UT_DEFINITION)</span>
<span class="sd">            &#39;m&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">_UNKNOWN_UNIT_STRING</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">_NO_UNIT_STRING</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bitmask</span> <span class="o">=</span> <span class="n">UT_ASCII</span>
            <span class="k">if</span> <span class="n">option</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">option</span> <span class="o">=</span> <span class="p">[</span><span class="n">option</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">option</span><span class="p">:</span>
                    <span class="n">bitmask</span> <span class="o">|=</span> <span class="n">i</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="n">bitmask</span> <span class="o">&amp;</span> \
                <span class="p">(</span><span class="n">UT_ASCII</span> <span class="o">|</span> <span class="n">UT_ISO_8859_1</span> <span class="o">|</span> <span class="n">UT_LATIN1</span> <span class="o">|</span> <span class="n">UT_UTF8</span><span class="p">)</span>
            <span class="n">endocing_str</span> <span class="o">=</span> <span class="n">_encoding_lookup</span><span class="p">[</span><span class="n">encoding</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">bitmask</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to format </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span></div>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">endocing_str</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *(read-only)* The full name of the unit.</span>

<span class="sd">        Formats the binary unit into a string representation using</span>
<span class="sd">        method :func:`cf_units.Unit.format` with keyword argument</span>
<span class="sd">        option=cf_units.UT_NAMES.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;watts&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.name</span>
<span class="sd">            &#39;watt&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">UT_NAMES</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *(read-only)* The symbolic representation of the unit.</span>

<span class="sd">        Formats the binary unit into a string representation using</span>
<span class="sd">        method :func:`cf_units.Unit.format`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;watts&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.symbol</span>
<span class="sd">            &#39;W&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_UNKNOWN_UNIT_SYMBOL</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_NO_UNIT_SYMBOL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">definition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *(read-only)* The symbolic decomposition of the unit.</span>

<span class="sd">        Formats the binary unit into a string representation using</span>
<span class="sd">        method :func:`cf_units.Unit.format` with keyword argument</span>
<span class="sd">        option=cf_units.UT_DEFINITION.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;watts&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.definition</span>
<span class="sd">            &#39;m2.kg.s-3&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_UNKNOWN_UNIT_SYMBOL</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_NO_UNIT_SYMBOL</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">UT_DEFINITION</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.offset_by_time"><a class="viewcode-back" href="../unit.html#cf_units.Unit.offset_by_time">[docs]</a>    <span class="k">def</span> <span class="nf">offset_by_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time unit offset with respect to the time origin.</span>

<span class="sd">        Args:</span>

<span class="sd">        * origin (float): Time origin as returned by the</span>
<span class="sd">          :func:`cf_units.encode_time` method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;hours&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.offset_by_time(cf_units.encode_time(1970, 1, 1, 0, 0, 0))</span>
<span class="sd">            Unit(&#39;h @ 19700101T000000.0000000 UTC&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">integer_types</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;a numeric type for the origin argument is&#39;</span>
                            <span class="s1">&#39; required&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">offset_by_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to offset </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span></div>
        <span class="k">return</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span>

<div class="viewcode-block" id="Unit.invert"><a class="viewcode-back" href="../unit.html#cf_units.Unit.invert">[docs]</a>    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invert the unit i.e. find the reciprocal of the unit, and return</span>
<span class="sd">        the Unit result.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unit.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.invert()</span>
<span class="sd">            Unit(&#39;m-1&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot invert a &#39;no-unit&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to invert </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.root"><a class="viewcode-back" href="../unit.html#cf_units.Unit.root">[docs]</a>    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the given root of the unit.</span>

<span class="sd">        Args:</span>

<span class="sd">        * root (int): Value by which the unit root is taken.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters^2&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.root(2)</span>
<span class="sd">            Unit(&#39;m&#39;)</span>

<span class="sd">        .. note::</span>

<span class="sd">            Taking a fractional root of a unit is not supported.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;An integer for the root argument is required&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot take the root of a &#39;no-unit&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># only update the unit if it is not scalar</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to take the root of </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                                          <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Unit.log"><a class="viewcode-back" href="../unit.html#cf_units.Unit.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the logorithmic unit corresponding to the given</span>
<span class="sd">        logorithmic base.</span>

<span class="sd">        Args:</span>

<span class="sd">        * base (int/float): Value of the logorithmic base.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u.log(2)</span>
<span class="sd">            Unit(&#39;lb(re 1 m)&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot take the logarithm of a &#39;no-unit&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;A numeric type for the base argument is &#39;</span>
                                <span class="s1">&#39; required&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdUnitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Failed to calculate logorithmic base of </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a simple string representation of the unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;miles/hour&#39;)</span>
<span class="sd">            &gt;&gt;&gt; str(u)</span>
<span class="sd">            &#39;miles/hour&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of the unit object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            string.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; repr(u)</span>
<span class="sd">            &quot;Unit(&#39;meters&#39;)&quot;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(&#39;</span><span class="si">%s</span><span class="s2">&#39;, calendar=&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_offset_common</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot offset a &#39;no-unit&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
            <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to offset </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_common</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="o">-</span><span class="n">other</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset_common</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_op_common</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op_func</span><span class="p">):</span>
        <span class="c1"># Convienience method to create a new unit from an operation between</span>
        <span class="c1"># the units &#39;self&#39; and &#39;other&#39;.</span>

        <span class="n">op_label</span> <span class="o">=</span> <span class="n">op_func</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">as_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">()</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot </span><span class="si">%s</span><span class="s2"> a &#39;no-unit&#39;.&quot;</span> <span class="o">%</span> <span class="n">op_label</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">()</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UNKNOWN</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">op_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Failed to </span><span class="si">%s</span><span class="s1"> </span><span class="si">%r</span><span class="s1"> by </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">op_label</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">calendar</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">,</span> <span class="n">calendar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># NB. Because we&#39;ve subclassed a tuple, we need to define this to</span>
        <span class="c1"># prevent the default tuple-repetition behaviour.</span>
        <span class="c1"># ie. 2 * (&#39;a&#39;, &#39;b&#39;) -&gt; (&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;)</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply the self unit by the other scale factor or unit and</span>
<span class="sd">        return the Unit result.</span>

<span class="sd">        Note that, multiplication involving an &#39;unknown&#39; unit will always</span>
<span class="sd">        result in an &#39;unknown&#39; unit.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other (int/float/string/Unit): Multiplication scale</span>
<span class="sd">          factor or unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unit.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v = cf_units.Unit(&#39;hertz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u*v</span>
<span class="sd">            Unit(&#39;m.s-1&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_common</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_ud</span><span class="o">.</span><span class="n">multiply</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the self unit by the other scale factor or unit and</span>
<span class="sd">        return the Unit result.</span>

<span class="sd">        Note that, division involving an &#39;unknown&#39; unit will always</span>
<span class="sd">        result in an &#39;unknown&#39; unit.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other (int/float/string/Unit): Division scale factor or unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unit.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;m.s-1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v = cf_units.Unit(&#39;hertz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u / v</span>
<span class="sd">            Unit(&#39;m&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_op_common</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_ud</span><span class="o">.</span><span class="n">divide</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the self unit by the other scale factor or unit and</span>
<span class="sd">        return the Unit result.</span>

<span class="sd">        Note that, division involving an &#39;unknown&#39; unit will always</span>
<span class="sd">        result in an &#39;unknown&#39; unit.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other (int/float/string/Unit): Division scale factor or unit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unit.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;m.s-1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; v = cf_units.Unit(&#39;hertz&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u / v</span>
<span class="sd">            Unit(&#39;m&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">power</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise the unit by the given power and return the Unit result.</span>

<span class="sd">        Note that, UDUNITS-2 does not support raising a</span>
<span class="sd">        non-dimensionless unit by a fractional power.</span>
<span class="sd">        Approximate floating point power behaviour has been implemented</span>
<span class="sd">        specifically for cf_units.</span>

<span class="sd">        Args:</span>

<span class="sd">        * power (int/float): Value by which the unit power is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Unit.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;meters&#39;)</span>
<span class="sd">            &gt;&gt;&gt; u**2</span>
<span class="sd">            Unit(&#39;m2&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">power</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;A numeric value is required for the power&#39;</span>
                            <span class="s1">&#39; argument.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_unknown</span><span class="p">():</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_no_unit</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot raise the power of a &#39;no-unit&#39;.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">Unit</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
            <span class="c1"># 1 ** N -&gt; 1</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># UDUNITS-2 does not support floating point raise/root.</span>
            <span class="c1"># But if the power is of the form 1/N, where N is an integer</span>
            <span class="c1"># (within a certain acceptable accuracy) then we can find the Nth</span>
            <span class="c1"># root.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">approx_equal</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">power</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">approx_equal</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">power</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">power</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot raise a unit by a decimal.&#39;</span><span class="p">)</span>
                <span class="n">root</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">power</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Failing that, check for powers which are (very nearly) simple</span>
                <span class="c1"># integer values.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">approx_equal</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">power</span><span class="p">)):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot raise a unit by a decimal (got </span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="n">power</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">power</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">power</span><span class="p">))</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ut_unit</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">power</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to raise the power of </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                                          <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">_Unit</span><span class="p">(</span><span class="n">_CATEGORY_UDUNIT</span><span class="p">,</span> <span class="n">ut_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Redefine the comparison/hash/ordering identity as used by</span>
        <span class="c1"># _OrderedHashable.</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the two units for equality and return the boolean result.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other (string/Unit): Unit to be compared.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; from cf_units import Unit</span>
<span class="sd">            &gt;&gt;&gt; Unit(&#39;meters&#39;) == Unit(&#39;millimeters&#39;)</span>
<span class="sd">            False</span>
<span class="sd">            &gt;&gt;&gt; Unit(&#39;meters&#39;) == &#39;m&#39;</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Compare category (i.e. unknown, no_unit, etc.).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">category</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Compare calendar as UDUNITS cannot handle calendars.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">calendar</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Compare UDUNITS.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the two units for inequality and return the boolean result.</span>

<span class="sd">        Args:</span>

<span class="sd">        * other (string/Unit): Unit to be compared.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Boolean.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; from cf_units import Unit</span>
<span class="sd">            &gt;&gt;&gt; Unit(&#39;meters&#39;) != Unit(&#39;millimeters&#39;)</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; Unit(&#39;meters&#39;) != &#39;m&#39;</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

<div class="viewcode-block" id="Unit.convert"><a class="viewcode-back" href="../unit.html#cf_units.Unit.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ctype</span><span class="o">=</span><span class="n">FLOAT64</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a single value or NumPy array of values from the current unit</span>
<span class="sd">        to the other target unit.</span>

<span class="sd">        If the units are not convertible, then no conversion will take place.</span>

<span class="sd">        Args:</span>

<span class="sd">        * value (int/float/numpy.ndarray):</span>
<span class="sd">            Value/s to be converted.</span>
<span class="sd">        * other (string/Unit):</span>
<span class="sd">            Target unit to convert to.</span>
<span class="sd">        * ctype (cf_units.FLOAT32/cf_units.FLOAT64):</span>
<span class="sd">            Floating point 32-bit single-precision (cf_units.FLOAT32) or</span>
<span class="sd">            64-bit double-precision (cf_units.FLOAT64) used for conversion</span>
<span class="sd">            when `value` is not a NumPy array or is a NumPy array composed of</span>
<span class="sd">            NumPy integers. The default is 64-bit double-precision conversion.</span>
<span class="sd">        * inplace (bool):</span>
<span class="sd">            If ``False``, return a deep copy of the value array. If ``True``,</span>
<span class="sd">            convert the values in-place. A new array will be created if</span>
<span class="sd">            ``value`` is an integer NumPy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float or numpy.ndarray of appropriate float type.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; c = cf_units.Unit(&#39;deg_c&#39;)</span>
<span class="sd">            &gt;&gt;&gt; f = cf_units.Unit(&#39;deg_f&#39;)</span>
<span class="sd">            &gt;&gt;&gt; c.convert(0, f)</span>
<span class="sd">            31.999999999999886</span>
<span class="sd">            &gt;&gt;&gt; c.convert(0, f, cf_units.FLOAT32)</span>
<span class="sd">            32.0</span>
<span class="sd">            &gt;&gt;&gt; a64 = np.arange(3, dtype=np.float64)</span>
<span class="sd">            &gt;&gt;&gt; c.convert(a64, f)</span>
<span class="sd">            array([32. , 33.8, 35.6])</span>
<span class="sd">            &gt;&gt;&gt; a32 = np.arange(3, dtype=np.float32)</span>
<span class="sd">            &gt;&gt;&gt; c.convert(a32, f)</span>
<span class="sd">            array([32. , 33.8, 35.6], dtype=float32)</span>

<span class="sd">        .. note::</span>

<span class="sd">           Conversion between unit calendars is not permitted unless the</span>
<span class="sd">           calendars are aliases, see :attr:`cf_units.CALENDAR_ALIASES`.</span>

<span class="sd">           &gt;&gt;&gt; from cf_units import Unit</span>
<span class="sd">           &gt;&gt;&gt; a = Unit(&#39;days since 1850-1-1&#39;, calendar=&#39;gregorian&#39;)</span>
<span class="sd">           &gt;&gt;&gt; b = Unit(&#39;days since 1851-1-1&#39;, calendar=&#39;standard&#39;)</span>
<span class="sd">           &gt;&gt;&gt; a.convert(365.75, b)</span>
<span class="sd">           0.75</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">as_unit</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_convertible</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># Use utime for converting reference times that are not using a</span>
            <span class="c1"># gregorian calendar as it handles these and udunits does not.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_time_reference</span><span class="p">()</span> \
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span> <span class="o">!=</span> <span class="n">CALENDAR_GREGORIAN</span><span class="p">:</span>
                <span class="n">ut1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utime</span><span class="p">()</span>
                <span class="n">ut2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">utime</span><span class="p">()</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ut2</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">ut1</span><span class="o">.</span><span class="n">num2date</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="c1"># Preserve the datatype of the input array if it was float32.</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
                   <span class="n">value</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ut_converter</span> <span class="o">=</span> <span class="n">_ud</span><span class="o">.</span><span class="n">get_converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">,</span>
                                                     <span class="n">other</span><span class="o">.</span><span class="n">ut_unit</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">_ud</span><span class="o">.</span><span class="n">UdunitsError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_propogate_error</span><span class="p">(</span><span class="s1">&#39;Failed to convert </span><span class="si">%r</span><span class="s1"> to </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                                          <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="c1"># Can only handle array of np.float32 or np.float64 so</span>
                    <span class="c1"># cast array of ints to array of floats of requested</span>
                    <span class="c1"># precision.</span>
                    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ctype</span><span class="p">)</span>
                    <span class="c1"># Convert arrays with explicit endianness to native</span>
                    <span class="c1"># endianness: udunits seems to be tripped up by arrays</span>
                    <span class="c1"># with endianness other than native.</span>
                    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">!=</span> <span class="s1">&#39;=&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s1">&#39;Unable to convert non-native byte ordered &#39;</span>
                                <span class="s1">&#39;array in-place. Consider byte-swapping &#39;</span>
                                <span class="s1">&#39;first.&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                    <span class="c1"># Strict type check of numpy array.</span>
                    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Expect a numpy array of &#39;</span><span class="si">%s</span><span class="s2">&#39; or &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="n">ctype</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
                    <span class="c1"># Utilise global convenience dictionary</span>
                    <span class="c1"># _cv_convert_array to convert our array in 1d form</span>
                    <span class="n">result_tmp</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
                    <span class="c1"># Do the actual conversion.</span>
                    <span class="n">_cv_convert_array</span><span class="p">[</span><span class="n">ctype</span><span class="p">](</span>
                            <span class="n">ut_converter</span><span class="p">,</span> <span class="n">result_tmp</span><span class="p">,</span> <span class="n">result_tmp</span><span class="p">)</span>
                    <span class="c1"># If result_tmp was a copy, not a view (i.e. not C</span>
                    <span class="c1"># contiguous), copy the data back to the original.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">shares_memory</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result_tmp</span><span class="p">):</span>
                        <span class="n">result_tmp</span> <span class="o">=</span> <span class="n">result_tmp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_tmp</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_tmp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ctype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_cv_convert_scalar</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid target type. Can only &#39;</span>
                                         <span class="s1">&#39;convert to float or double.&#39;</span><span class="p">)</span>
                    <span class="c1"># Utilise global convenience dictionary</span>
                    <span class="c1"># _cv_convert_scalar</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">_cv_convert_scalar</span><span class="p">[</span><span class="n">ctype</span><span class="p">](</span><span class="n">ut_converter</span><span class="p">,</span>
                                                       <span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unable to convert from &#39;</span><span class="si">%r</span><span class="s2">&#39; to &#39;</span><span class="si">%r</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span></div>
                             <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

<div class="viewcode-block" id="Unit.utime"><a class="viewcode-back" href="../unit.html#cf_units.Unit.utime">[docs]</a>    <span class="k">def</span> <span class="nf">utime</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a cftime.utime object which performs conversions of</span>
<span class="sd">        numeric time values to/from datetime objects given the current</span>
<span class="sd">        calendar and unit time reference.</span>

<span class="sd">        The current unit time reference must be of the form:</span>
<span class="sd">        &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39;</span>
<span class="sd">        i.e. &#39;hours since 1970-01-01 00:00:00&#39;</span>

<span class="sd">        Returns:</span>
<span class="sd">            cftime.utime.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">            ...                   calendar=cf_units.CALENDAR_STANDARD)</span>
<span class="sd">            &gt;&gt;&gt; ut = u.utime()</span>
<span class="sd">            &gt;&gt;&gt; ut.num2date(2)</span>
<span class="sd">            datetime.datetime(1970, 1, 1, 2, 0, 0, 6)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unit has undefined calendar&#39;</span><span class="p">)</span>

        <span class="c1"># `cftime` cannot parse long time intervals (&quot;months&quot; or &quot;years&quot;).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_long_time_interval</span><span class="p">():</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">emsg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Time units with interval of &quot;months&quot;, &quot;years&quot; &#39;</span>
                    <span class="s1">&#39;(or singular of these) cannot be processed, got </span><span class="si">{!r}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">emsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interval</span><span class="p">))</span>

        <span class="c1">#</span>
        <span class="c1"># ensure to strip out non-parsable &#39;UTC&#39; postfix, which</span>
        <span class="c1"># is generated by UDUNITS-2 formatted output</span>
        <span class="c1">#</span></div>
        <span class="k">return</span> <span class="n">cftime</span><span class="o">.</span><span class="n">utime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot; UTC&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">calendar</span><span class="p">)</span>

<div class="viewcode-block" id="Unit.date2num"><a class="viewcode-back" href="../unit.html#cf_units.Unit.date2num">[docs]</a>    <span class="k">def</span> <span class="nf">date2num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the numeric time value calculated from the datetime</span>
<span class="sd">        object using the current calendar and unit time reference.</span>

<span class="sd">        The current unit time reference must be of the form:</span>
<span class="sd">        &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39;</span>
<span class="sd">        i.e. &#39;hours since 1970-01-01 00:00:00&#39;</span>

<span class="sd">        Works for scalars, sequences and numpy arrays. Returns a scalar</span>
<span class="sd">        if input is a scalar, else returns a numpy array.</span>

<span class="sd">        Args:</span>

<span class="sd">        * date (datetime):</span>
<span class="sd">            A datetime object or a sequence of datetime objects.</span>
<span class="sd">            The datetime objects should not include a time-zone offset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float or numpy.ndarray of float.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; import datetime</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">            ...                   calendar=cf_units.CALENDAR_STANDARD)</span>
<span class="sd">            &gt;&gt;&gt; u.date2num(datetime.datetime(1970, 1, 1, 5))</span>
<span class="sd">            5.00000000372529</span>
<span class="sd">            &gt;&gt;&gt; u.date2num([datetime.datetime(1970, 1, 1, 5),</span>
<span class="sd">            ...             datetime.datetime(1970, 1, 1, 6)])</span>
<span class="sd">            array([5., 6.])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cdf_utime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utime</span><span class="p">()</span>
        <span class="n">date</span> <span class="o">=</span> <span class="n">_discard_microsecond</span><span class="p">(</span><span class="n">date</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">cdf_utime</span><span class="o">.</span><span class="n">date2num</span><span class="p">(</span><span class="n">date</span><span class="p">)</span>

<div class="viewcode-block" id="Unit.num2date"><a class="viewcode-back" href="../unit.html#cf_units.Unit.num2date">[docs]</a>    <span class="k">def</span> <span class="nf">num2date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a datetime-like object calculated from the numeric time</span>
<span class="sd">        value using the current calendar and the unit time reference.</span>

<span class="sd">        The current unit time reference must be of the form:</span>
<span class="sd">        &#39;&lt;time-unit&gt; since &lt;time-origin&gt;&#39;</span>
<span class="sd">        i.e. &#39;hours since 1970-01-01 00:00:00&#39;</span>

<span class="sd">        The datetime objects returned are &#39;real&#39; Python datetime objects</span>
<span class="sd">        if the date falls in the Gregorian calendar (i.e. the calendar</span>
<span class="sd">        is &#39;standard&#39;, &#39;gregorian&#39;, or &#39;proleptic_gregorian&#39; and the</span>
<span class="sd">        date is after 1582-10-15). Otherwise a &#39;phoney&#39; datetime-like</span>
<span class="sd">        object (cftime.datetime) is returned which can handle dates</span>
<span class="sd">        that don&#39;t exist in the Proleptic Gregorian calendar.</span>

<span class="sd">        Works for scalars, sequences and numpy arrays. Returns a scalar</span>
<span class="sd">        if input is a scalar, else returns a numpy array.</span>

<span class="sd">        Args:</span>

<span class="sd">        * time_value (float): Numeric time value/s. Maximum resolution</span>
<span class="sd">          is 1 second.</span>

<span class="sd">        Returns:</span>
<span class="sd">            datetime, or numpy.ndarray of datetime object.</span>

<span class="sd">        For example:</span>

<span class="sd">            &gt;&gt;&gt; import cf_units</span>
<span class="sd">            &gt;&gt;&gt; u = cf_units.Unit(&#39;hours since 1970-01-01 00:00:00&#39;,</span>
<span class="sd">            ...                   calendar=cf_units.CALENDAR_STANDARD)</span>
<span class="sd">            &gt;&gt;&gt; u.num2date(6)</span>
<span class="sd">            datetime.datetime(1970, 1, 1, 6, 0)</span>
<span class="sd">            &gt;&gt;&gt; u.num2date([6, 7])</span>
<span class="sd">            array([datetime.datetime(1970, 1, 1, 6, 0),</span>
<span class="sd">                   datetime.datetime(1970, 1, 1, 7, 0)], dtype=object)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cdf_utime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utime</span><span class="p">()</span></div></div>
        <span class="k">return</span> <span class="n">_num2date_to_nearest_second</span><span class="p">(</span><span class="n">time_value</span><span class="p">,</span> <span class="n">cdf_utime</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;British Crown Copyright 2015 - 2018, Met Office.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>